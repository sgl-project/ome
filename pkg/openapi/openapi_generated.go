//go:build !ignore_autogenerated
// +build !ignore_autogenerated

// Code generated by openapi-gen. DO NOT EDIT.

package openapi

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCapabilities":       schema_pkg_apis_ome_v1beta1_AcceleratorCapabilities(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClass":              schema_pkg_apis_ome_v1beta1_AcceleratorClass(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassList":          schema_pkg_apis_ome_v1beta1_AcceleratorClassList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassSpec":          schema_pkg_apis_ome_v1beta1_AcceleratorClassSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassStatus":        schema_pkg_apis_ome_v1beta1_AcceleratorClassStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorConstraints":        schema_pkg_apis_ome_v1beta1_AcceleratorConstraints(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCost":               schema_pkg_apis_ome_v1beta1_AcceleratorCost(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorDiscovery":          schema_pkg_apis_ome_v1beta1_AcceleratorDiscovery(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorIntegration":        schema_pkg_apis_ome_v1beta1_AcceleratorIntegration(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorLatency":            schema_pkg_apis_ome_v1beta1_AcceleratorLatency(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorModelConfig":        schema_pkg_apis_ome_v1beta1_AcceleratorModelConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorPerformance":        schema_pkg_apis_ome_v1beta1_AcceleratorPerformance(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorRequirements":       schema_pkg_apis_ome_v1beta1_AcceleratorRequirements(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorResource":           schema_pkg_apis_ome_v1beta1_AcceleratorResource(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelection":          schema_pkg_apis_ome_v1beta1_AcceleratorSelection(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector":           schema_pkg_apis_ome_v1beta1_AcceleratorSelector(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditConfig":                   schema_pkg_apis_ome_v1beta1_AuditConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditDestinationConfig":        schema_pkg_apis_ome_v1beta1_AuditDestinationConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditFileConfig":               schema_pkg_apis_ome_v1beta1_AuditFileConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditHTTPConfig":               schema_pkg_apis_ome_v1beta1_AuditHTTPConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditSyslogConfig":             schema_pkg_apis_ome_v1beta1_AuditSyslogConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig":                    schema_pkg_apis_ome_v1beta1_AuthConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthzConfigSource":             schema_pkg_apis_ome_v1beta1_AuthzConfigSource(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModel":                     schema_pkg_apis_ome_v1beta1_BaseModel(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelList":                 schema_pkg_apis_ome_v1beta1_BaseModelList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelSpec":                 schema_pkg_apis_ome_v1beta1_BaseModelSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BasicCredentials":              schema_pkg_apis_ome_v1beta1_BasicCredentials(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJob":                  schema_pkg_apis_ome_v1beta1_BenchmarkJob(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobList":              schema_pkg_apis_ome_v1beta1_BenchmarkJobList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobSpec":              schema_pkg_apis_ome_v1beta1_BenchmarkJobSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobStatus":            schema_pkg_apis_ome_v1beta1_BenchmarkJobStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BodyFilter":                    schema_pkg_apis_ome_v1beta1_BodyFilter(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BuiltinPermissionProfile":      schema_pkg_apis_ome_v1beta1_BuiltinPermissionProfile(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CircuitBreakerConfig":          schema_pkg_apis_ome_v1beta1_CircuitBreakerConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClientCertCredentials":         schema_pkg_apis_ome_v1beta1_ClientCertCredentials(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterBaseModel":              schema_pkg_apis_ome_v1beta1_ClusterBaseModel(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterBaseModelList":          schema_pkg_apis_ome_v1beta1_ClusterBaseModelList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPGateway":             schema_pkg_apis_ome_v1beta1_ClusterMCPGateway(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPGatewayList":         schema_pkg_apis_ome_v1beta1_ClusterMCPGatewayList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPServer":              schema_pkg_apis_ome_v1beta1_ClusterMCPServer(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPServerList":          schema_pkg_apis_ome_v1beta1_ClusterMCPServerList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterServingRuntime":         schema_pkg_apis_ome_v1beta1_ClusterServingRuntime(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterServingRuntimeList":     schema_pkg_apis_ome_v1beta1_ClusterServingRuntimeList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceConfig":              schema_pkg_apis_ome_v1beta1_ComplianceConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceEncryptionConfig":    schema_pkg_apis_ome_v1beta1_ComplianceEncryptionConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComponentExtensionSpec":        schema_pkg_apis_ome_v1beta1_ComponentExtensionSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComponentStatusSpec":           schema_pkg_apis_ome_v1beta1_ComponentStatusSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationError":         schema_pkg_apis_ome_v1beta1_ConfigValidationError(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationStatus":        schema_pkg_apis_ome_v1beta1_ConfigValidationStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef":                 schema_pkg_apis_ome_v1beta1_CredentialRef(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CustomMetric":                  schema_pkg_apis_ome_v1beta1_CustomMetric(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DataRetentionConfig":           schema_pkg_apis_ome_v1beta1_DataRetentionConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DecoderSpec":                   schema_pkg_apis_ome_v1beta1_DecoderSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ElicitationPolicyConfig":       schema_pkg_apis_ome_v1beta1_ElicitationPolicyConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.Endpoint":                      schema_pkg_apis_ome_v1beta1_Endpoint(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EndpointSpec":                  schema_pkg_apis_ome_v1beta1_EndpointSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EngineSpec":                    schema_pkg_apis_ome_v1beta1_EngineSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FailureInfo":                   schema_pkg_apis_ome_v1beta1_FailureInfo(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeight":               schema_pkg_apis_ome_v1beta1_FineTunedWeight(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeightList":           schema_pkg_apis_ome_v1beta1_FineTunedWeightList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeightSpec":           schema_pkg_apis_ome_v1beta1_FineTunedWeightSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GRPCTransportConfig":           schema_pkg_apis_ome_v1beta1_GRPCTransportConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressConfig":          schema_pkg_apis_ome_v1beta1_GatewayIngressConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressHost":            schema_pkg_apis_ome_v1beta1_GatewayIngressHost(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressPath":            schema_pkg_apis_ome_v1beta1_GatewayIngressPath(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressTLS":             schema_pkg_apis_ome_v1beta1_GatewayIngressTLS(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayMetrics":                schema_pkg_apis_ome_v1beta1_GatewayMetrics(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServiceConfig":          schema_pkg_apis_ome_v1beta1_GatewayServiceConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServicePort":            schema_pkg_apis_ome_v1beta1_GatewayServicePort(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayTransportConfig":        schema_pkg_apis_ome_v1beta1_GatewayTransportConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HTTPTransportConfig":           schema_pkg_apis_ome_v1beta1_HTTPTransportConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HeaderFilter":                  schema_pkg_apis_ome_v1beta1_HeaderFilter(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthCheckConfig":             schema_pkg_apis_ome_v1beta1_HealthCheckConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthEndpointConfig":          schema_pkg_apis_ome_v1beta1_HealthEndpointConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HostedMCPServer":               schema_pkg_apis_ome_v1beta1_HostedMCPServer(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HuggingFaceSecretReference":    schema_pkg_apis_ome_v1beta1_HuggingFaceSecretReference(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceService":              schema_pkg_apis_ome_v1beta1_InferenceService(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceList":          schema_pkg_apis_ome_v1beta1_InferenceServiceList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceReference":     schema_pkg_apis_ome_v1beta1_InferenceServiceReference(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceSpec":          schema_pkg_apis_ome_v1beta1_InferenceServiceSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceStatus":        schema_pkg_apis_ome_v1beta1_InferenceServiceStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineAuthzConfig":             schema_pkg_apis_ome_v1beta1_InlineAuthzConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineOIDCConfig":              schema_pkg_apis_ome_v1beta1_InlineOIDCConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.JWTCredentials":                schema_pkg_apis_ome_v1beta1_JWTCredentials(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig":                    schema_pkg_apis_ome_v1beta1_KedaConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubeResourcePermission":        schema_pkg_apis_ome_v1beta1_KubeResourcePermission(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubernetesOIDCConfig":          schema_pkg_apis_ome_v1beta1_KubernetesOIDCConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LeaderSpec":                    schema_pkg_apis_ome_v1beta1_LeaderSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LogFileConfig":                 schema_pkg_apis_ome_v1beta1_LogFileConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LoggingConfig":                 schema_pkg_apis_ome_v1beta1_LoggingConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPAuthenticationConfig":       schema_pkg_apis_ome_v1beta1_MCPAuthenticationConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities":               schema_pkg_apis_ome_v1beta1_MCPCapabilities(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGateway":                    schema_pkg_apis_ome_v1beta1_MCPGateway(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayList":                schema_pkg_apis_ome_v1beta1_MCPGatewayList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayNetworkConfig":       schema_pkg_apis_ome_v1beta1_MCPGatewayNetworkConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayObservabilityConfig": schema_pkg_apis_ome_v1beta1_MCPGatewayObservabilityConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayPolicyConfig":        schema_pkg_apis_ome_v1beta1_MCPGatewayPolicyConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayServerStatus":        schema_pkg_apis_ome_v1beta1_MCPGatewayServerStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewaySpec":                schema_pkg_apis_ome_v1beta1_MCPGatewaySpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayStatus":              schema_pkg_apis_ome_v1beta1_MCPGatewayStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPProtocolVersionConfig":      schema_pkg_apis_ome_v1beta1_MCPProtocolVersionConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServer":                     schema_pkg_apis_ome_v1beta1_MCPServer(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerDiscoveryConfig":      schema_pkg_apis_ome_v1beta1_MCPServerDiscoveryConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerList":                 schema_pkg_apis_ome_v1beta1_MCPServerList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerRef":                  schema_pkg_apis_ome_v1beta1_MCPServerRef(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerSpec":                 schema_pkg_apis_ome_v1beta1_MCPServerSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerStatus":               schema_pkg_apis_ome_v1beta1_MCPServerStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MetricsConfig":                 schema_pkg_apis_ome_v1beta1_MetricsConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelCopies":                   schema_pkg_apis_ome_v1beta1_ModelCopies(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelExtensionSpec":            schema_pkg_apis_ome_v1beta1_ModelExtensionSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFormat":                   schema_pkg_apis_ome_v1beta1_ModelFormat(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFrameworkSpec":            schema_pkg_apis_ome_v1beta1_ModelFrameworkSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRef":                      schema_pkg_apis_ome_v1beta1_ModelRef(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRevisionStates":           schema_pkg_apis_ome_v1beta1_ModelRevisionStates(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSizeRangeSpec":            schema_pkg_apis_ome_v1beta1_ModelSizeRangeSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSpec":                     schema_pkg_apis_ome_v1beta1_ModelSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatus":                   schema_pkg_apis_ome_v1beta1_ModelStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec":               schema_pkg_apis_ome_v1beta1_ModelStatusSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkPermission":             schema_pkg_apis_ome_v1beta1_NetworkPermission(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkUsageInfo":              schema_pkg_apis_ome_v1beta1_NetworkUsageInfo(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OAuth2Credentials":             schema_pkg_apis_ome_v1beta1_OAuth2Credentials(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OIDCConfigSource":              schema_pkg_apis_ome_v1beta1_OIDCConfigSource(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ObjectReference":               schema_pkg_apis_ome_v1beta1_ObjectReference(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIDetectionConfig":            schema_pkg_apis_ome_v1beta1_PIIDetectionConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIPattern":                    schema_pkg_apis_ome_v1beta1_PIIPattern(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSource":       schema_pkg_apis_ome_v1beta1_PermissionProfileSource(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSpec":         schema_pkg_apis_ome_v1beta1_PermissionProfileSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionRule":                schema_pkg_apis_ome_v1beta1_PermissionRule(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PodOverride":                   schema_pkg_apis_ome_v1beta1_PodOverride(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PodSpec":                       schema_pkg_apis_ome_v1beta1_PodSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PredictorExtensionSpec":        schema_pkg_apis_ome_v1beta1_PredictorExtensionSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PredictorSpec":                 schema_pkg_apis_ome_v1beta1_PredictorSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PromptRegistryStatus":          schema_pkg_apis_ome_v1beta1_PromptRegistryStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitConfig":               schema_pkg_apis_ome_v1beta1_RateLimitConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy":               schema_pkg_apis_ome_v1beta1_RateLimitPolicy(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RemoteMCPServer":               schema_pkg_apis_ome_v1beta1_RemoteMCPServer(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RequestFilteringConfig":        schema_pkg_apis_ome_v1beta1_RequestFilteringConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceRegistryStatus":        schema_pkg_apis_ome_v1beta1_ResourceRegistryStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceUsageStatus":           schema_pkg_apis_ome_v1beta1_ResourceUsageStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResponseFilteringConfig":       schema_pkg_apis_ome_v1beta1_ResponseFilteringConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RouterSpec":                    schema_pkg_apis_ome_v1beta1_RouterSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec":                    schema_pkg_apis_ome_v1beta1_RunnerSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingPolicyConfig":          schema_pkg_apis_ome_v1beta1_SamplingPolicyConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingRateLimit":             schema_pkg_apis_ome_v1beta1_SamplingRateLimit(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServerStatusSummary":           schema_pkg_apis_ome_v1beta1_ServerStatusSummary(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServiceMetadata":               schema_pkg_apis_ome_v1beta1_ServiceMetadata(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntime":                schema_pkg_apis_ome_v1beta1_ServingRuntime(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeList":            schema_pkg_apis_ome_v1beta1_ServingRuntimeList(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimePodSpec":         schema_pkg_apis_ome_v1beta1_ServingRuntimePodSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeRef":             schema_pkg_apis_ome_v1beta1_ServingRuntimeRef(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec":            schema_pkg_apis_ome_v1beta1_ServingRuntimeSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeStatus":          schema_pkg_apis_ome_v1beta1_ServingRuntimeStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SessionIsolationConfig":        schema_pkg_apis_ome_v1beta1_SessionIsolationConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageMetrics":                schema_pkg_apis_ome_v1beta1_StorageMetrics(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec":                   schema_pkg_apis_ome_v1beta1_StorageSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageUsageInfo":              schema_pkg_apis_ome_v1beta1_StorageUsageInfo(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SupportedModelFormat":          schema_pkg_apis_ome_v1beta1_SupportedModelFormat(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SupportedRuntime":              schema_pkg_apis_ome_v1beta1_SupportedRuntime(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TensorParallelismConfig":       schema_pkg_apis_ome_v1beta1_TensorParallelismConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ToolRegistryStatus":            schema_pkg_apis_ome_v1beta1_ToolRegistryStatus(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TracingConfig":                 schema_pkg_apis_ome_v1beta1_TracingConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WebSocketTransportConfig":      schema_pkg_apis_ome_v1beta1_WebSocketTransportConfig(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerPodSpec":                 schema_pkg_apis_ome_v1beta1_WorkerPodSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec":                    schema_pkg_apis_ome_v1beta1_WorkerSpec(ref),
		"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkflowStatus":                schema_pkg_apis_ome_v1beta1_WorkflowStatus(ref),
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorCapabilities(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"memoryGB": {
						SchemaProps: spec.SchemaProps{
							Description: "Memory capacity in GB",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"computeCapability": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute capability (NVIDIA) or equivalent",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"levelZeroVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Level Zero version (for Intel accelerators)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"clockSpeedMHz": {
						SchemaProps: spec.SchemaProps{
							Description: "Clock speeds",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"memoryBandwidthGBps": {
						SchemaProps: spec.SchemaProps{
							Description: "Memory bandwidth",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"features": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Features supported by this accelerator",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"performance": {
						SchemaProps: spec.SchemaProps{
							Description: "Performance metrics",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorPerformance"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorPerformance", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorClass(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClassStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorClassList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorClassList contains a list of AcceleratorClass",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClass"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorClass", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorClassSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"vendor": {
						SchemaProps: spec.SchemaProps{
							Description: "Vendor of the accelerator (nvidia, amd, intel, etc.)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"family": {
						SchemaProps: spec.SchemaProps{
							Description: "Family of the accelerator (ampere, hopper, cdna2, etc.)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"model": {
						SchemaProps: spec.SchemaProps{
							Description: "Model name (a100, h100, mi250x, etc.)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"discovery": {
						SchemaProps: spec.SchemaProps{
							Description: "Discovery patterns to identify nodes with this accelerator",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorDiscovery"),
						},
					},
					"capabilities": {
						SchemaProps: spec.SchemaProps{
							Description: "Capabilities of this accelerator class",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCapabilities"),
						},
					},
					"resources": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources exposed by this accelerator",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorResource"),
									},
								},
							},
						},
					},
					"integration": {
						SchemaProps: spec.SchemaProps{
							Description: "Integration with external systems",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorIntegration"),
						},
					},
					"cost": {
						SchemaProps: spec.SchemaProps{
							Description: "Cost information for optimization decisions",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCost"),
						},
					},
				},
				Required: []string{"discovery", "capabilities"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCapabilities", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorCost", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorDiscovery", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorIntegration", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorResource"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorClassStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"nodes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Nodes that have this accelerator",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"totalAccelerators": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of accelerators in the cluster",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableAccelerators": {
						SchemaProps: spec.SchemaProps{
							Description: "Available accelerators (not allocated)",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lastUpdated": {
						SchemaProps: spec.SchemaProps{
							Description: "Last update time",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions represent the latest available observations",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
					"availableNodes": {
						SchemaProps: spec.SchemaProps{
							Description: "AvailableNodes is the number of nodes that have this accelerator available",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Condition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorConstraints(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorConstraints defines requirements for accelerator selection",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"minMemory": {
						SchemaProps: spec.SchemaProps{
							Description: "MinMemory in GB",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"maxMemory": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxMemory in GB (useful for cost control)",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"minComputeCapability": {
						SchemaProps: spec.SchemaProps{
							Description: "MinComputeCapability in TFLOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"requiredFeatures": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RequiredFeatures that must be present",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"excludedClasses": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ExcludedClasses lists AcceleratorClasses to avoid",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"architectureFamilies": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ArchitectureFamilies limits selection to specific families Examples: [\"nvidia-hopper\", \"nvidia-ampere\"]",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorCost(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"perHour": {
						SchemaProps: spec.SchemaProps{
							Description: "Cost per hour in dollars",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"perMillionTokens": {
						SchemaProps: spec.SchemaProps{
							Description: "Cost per million tokens (for usage-based pricing)",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"spotPerHour": {
						SchemaProps: spec.SchemaProps{
							Description: "Spot instance pricing if available",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"tier": {
						SchemaProps: spec.SchemaProps{
							Description: "Cost tier for simplified selection (low, medium, high)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorDiscovery(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector to identify nodes with this accelerator",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"nodeSelectorTerms": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelectorTerms for more complex node selection",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.NodeSelectorTerm"),
									},
								},
							},
						},
					},
					"pciVendorID": {
						SchemaProps: spec.SchemaProps{
							Description: "PCIVendorID for device discovery (e.g., \"10de\" for NVIDIA)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"deviceIDs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "DeviceIDs list of PCI device IDs",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.NodeSelectorTerm"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorIntegration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"kueueResourceFlavor": {
						SchemaProps: spec.SchemaProps{
							Description: "KueueResourceFlavor name to sync with",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volcanoGPUType": {
						SchemaProps: spec.SchemaProps{
							Description: "VolcanoGPUType for Volcano integration",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorLatency(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"averageMillis": {
						SchemaProps: spec.SchemaProps{
							Description: "Average latency in milliseconds",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"maximumMillis": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum latency in milliseconds",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorModelConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorModelConfig provides accelerator-specific overrides for this model format",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"minMemoryPerBillionParams": {
						SchemaProps: spec.SchemaProps{
							Description: "MinMemoryPerBillionParams specifies memory required per billion parameters Used to calculate if a model fits on the accelerator",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"tensorParallelismOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "TensorParallelismOverride overrides the default tensor parallelism settings",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TensorParallelismConfig"),
						},
					},
					"runtimeArgsOverride": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeArgsOverride provides accelerator-specific runtime arguments",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"environmentOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "EnvironmentOverride provides accelerator-specific environment variables",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TensorParallelismConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorPerformance(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"fp32Tflops": {
						SchemaProps: spec.SchemaProps{
							Description: "FP32 performance in TFLOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"fp16Tflops": {
						SchemaProps: spec.SchemaProps{
							Description: "FP16 performance in TFLOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"int8Tops": {
						SchemaProps: spec.SchemaProps{
							Description: "INT8 performance in TOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"int4Tops": {
						SchemaProps: spec.SchemaProps{
							Description: "INT4 performance in TOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"latency": {
						SchemaProps: spec.SchemaProps{
							Description: "Latency metrics",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorLatency"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorLatency"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorRequirements(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorRequirements specifies the accelerator requirements for this runtime",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"acceleratorClasses": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorClasses lists the names of AcceleratorClasses this runtime supports If empty, the runtime supports any accelerator",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minMemory": {
						SchemaProps: spec.SchemaProps{
							Description: "MinMemory specifies minimum GPU memory required in GB",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"minComputeCapability": {
						SchemaProps: spec.SchemaProps{
							Description: "MinComputeCapability specifies minimum compute capability in TFLOPS",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"requiredFeatures": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "RequiredFeatures lists hardware features that must be present Examples: [\"tensor-cores\", \"fp8\", \"nvlink\"]",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"preferredPrecisions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "PreferredPrecisions lists numeric precisions in order of preference Examples: [\"fp8\", \"fp16\", \"fp32\"]",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorResource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the resource (e.g., nvidia.com/gpu)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"quantity": {
						SchemaProps: spec.SchemaProps{
							Description: "Quantity per accelerator",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"divisible": {
						SchemaProps: spec.SchemaProps{
							Description: "Divisible indicates if the resource can be subdivided",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorSelection(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorSelection shows what accelerator was selected and why",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"acceleratorClass": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorClass that was selected",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "Reason explains why this accelerator was selected",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector that was applied to pods",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"resourceRequests": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourceRequests that were applied to pods",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"acceleratorClass"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AcceleratorSelector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AcceleratorSelector defines how to select accelerators for the InferenceService",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"acceleratorClass": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorClass explicitly selects a specific AcceleratorClass Takes precedence over other selectors",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"constraints": {
						SchemaProps: spec.SchemaProps{
							Description: "Constraints defines requirements that accelerators must meet",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorConstraints"),
						},
					},
					"policy": {
						SchemaProps: spec.SchemaProps{
							Description: "Policy defines the selection policy when multiple accelerators match",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorConstraints"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuditConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuditConfig defines audit logging configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether audit logging is active.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"level": {
						SchemaProps: spec.SchemaProps{
							Description: "Level defines the audit logging level.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"destination": {
						SchemaProps: spec.SchemaProps{
							Description: "Destination defines where audit logs are sent.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditDestinationConfig"),
						},
					},
					"format": {
						SchemaProps: spec.SchemaProps{
							Description: "Format defines the audit log format.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"includeMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "IncludeMetadata controls whether to include request metadata in audit logs.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditDestinationConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuditDestinationConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuditDestinationConfig defines audit log destinations.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type defines the destination type.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"file": {
						SchemaProps: spec.SchemaProps{
							Description: "File defines file-based audit logging.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditFileConfig"),
						},
					},
					"http": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP defines HTTP-based audit logging.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditHTTPConfig"),
						},
					},
					"syslog": {
						SchemaProps: spec.SchemaProps{
							Description: "Syslog defines syslog-based audit logging.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditSyslogConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditFileConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditHTTPConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditSyslogConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuditFileConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuditFileConfig defines file-based audit logging.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path defines the audit log file path.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxSize defines the maximum log file size before rotation.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"maxBackups": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxBackups defines the maximum number of backup files to keep.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuditHTTPConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuditHTTPConfig defines HTTP-based audit logging.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint defines the HTTP endpoint for audit logs.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"method": {
						SchemaProps: spec.SchemaProps{
							Description: "Method defines the HTTP method to use.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"headers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Headers define additional HTTP headers.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout defines the HTTP request timeout.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
				Required: []string{"endpoint"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuditSyslogConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuditSyslogConfig defines syslog-based audit logging.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"server": {
						SchemaProps: spec.SchemaProps{
							Description: "Server defines the syslog server address.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"protocol": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol defines the syslog protocol.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"facility": {
						SchemaProps: spec.SchemaProps{
							Description: "Facility defines the syslog facility.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"server"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_AuthConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuthConfig provides unified authentication configuration for all components.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"method": {
						SchemaProps: spec.SchemaProps{
							Description: "Method defines the authentication method to use.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"token": {
						SchemaProps: spec.SchemaProps{
							Description: "Token provides the authentication token (Bearer, API Key).",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"basic": {
						SchemaProps: spec.SchemaProps{
							Description: "Basic provides basic authentication credentials.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BasicCredentials"),
						},
					},
					"jwt": {
						SchemaProps: spec.SchemaProps{
							Description: "JWT provides JWT authentication configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.JWTCredentials"),
						},
					},
					"clientCert": {
						SchemaProps: spec.SchemaProps{
							Description: "ClientCert provides client certificate authentication.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClientCertCredentials"),
						},
					},
					"oAuth2": {
						SchemaProps: spec.SchemaProps{
							Description: "OAuth2 provides OAuth2 authentication configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OAuth2Credentials"),
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout defines the authentication request timeout.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
				Required: []string{"method"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BasicCredentials", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClientCertCredentials", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.JWTCredentials", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OAuth2Credentials", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_AuthzConfigSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AuthzConfigSource defines the source of an authorization policy. Only one of the fields may be set.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"configMap": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMap references a ConfigMap containing the authorization policy.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"inline": {
						SchemaProps: spec.SchemaProps{
							Description: "Inline contains an embedded authorization policy.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineAuthzConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineAuthzConfig", "k8s.io/api/core/v1.ConfigMapKeySelector"},
	}
}

func schema_pkg_apis_ome_v1beta1_BaseModel(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BaseModel is the Schema for the basemodels API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_BaseModelList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BaseModelList contains a list of BaseModel",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModel"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModel", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_BaseModelSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BaseModelSpec defines the desired state of BaseModel",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"modelFormat": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFormat"),
						},
					},
					"modelType": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelType defines the architecture family of the model (e.g., \"bert\", \"gpt2\", \"llama\"). This value typically corresponds to the \"model_type\" field in a Hugging Face model's config.json. It is used to identify the transformer architecture and inform runtime selection and tokenizer behavior.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelFramework": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelFramework specifies the underlying framework used by the model, such as \"ONNX\", \"TensorFlow\", \"PyTorch\", \"Transformer\", or \"TensorRTLLM\". This value helps determine the appropriate runtime for model serving.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFrameworkSpec"),
						},
					},
					"modelArchitecture": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelArchitecture specifies the concrete model implementation or head, such as \"LlamaForCausalLM\", \"GemmaForCausalLM\", or \"MixtralForCausalLM\". This is often derived from the \"architectures\" field in Hugging Face config.json.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"quantization": {
						SchemaProps: spec.SchemaProps{
							Description: "Quantization defines the quantization scheme applied to the model weights, such as \"fp8\", \"fbgemm_fp8\", or \"int4\". This influences runtime compatibility and performance.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelParameterSize": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelParameterSize indicates the total number of parameters in the model, expressed in human-readable form such as \"7B\", \"13B\", or \"175B\". This can be used for scheduling or runtime selection.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelCapabilities": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ModelCapabilities of the model, e.g., \"TEXT_GENERATION\", \"TEXT_SUMMARIZATION\", \"TEXT_EMBEDDINGS\"",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"modelConfiguration": {
						SchemaProps: spec.SchemaProps{
							Description: "Configuration of the model, stored as generic JSON for flexibility.",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"storage": {
						SchemaProps: spec.SchemaProps{
							Description: "Storage configuration for the model",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec"),
						},
					},
					"displayName": {
						SchemaProps: spec.SchemaProps{
							Description: "DisplayName is the user-friendly name of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"disabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the model is enabled or not",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"vendor": {
						SchemaProps: spec.SchemaProps{
							Description: "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"compartmentID": {
						SchemaProps: spec.SchemaProps{
							Description: "CompartmentID is the compartment ID of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servingMode": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"maxTokens": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxTokens is the maximum number of tokens that can be processed by the model",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"additionalMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Additional metadata for the model",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"storage"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFormat", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFrameworkSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec", "k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_pkg_apis_ome_v1beta1_BasicCredentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BasicCredentials defines basic authentication credentials.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username for basic authentication.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password references the password secret.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
				},
				Required: []string{"username", "password"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"},
	}
}

func schema_pkg_apis_ome_v1beta1_BenchmarkJob(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BenchmarkJob is the schema for the BenchmarkJobs API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJobStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_BenchmarkJobList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BenchmarkJobList contains a list of BenchmarkJob",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJob"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BenchmarkJob", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_BenchmarkJobSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BenchmarkJobSpec defines the specification for a benchmark job. All fields within this specification collectively represent the desired state and configuration of a BenchmarkJob.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"huggingFaceSecretReference": {
						SchemaProps: spec.SchemaProps{
							Description: "HuggingFaceSecretReference is a reference to a Kubernetes Secret containing the Hugging Face API key. The referenced Secret must reside in the same namespace as the BenchmarkJob. This field replaces the raw HuggingFaceAPIKey field for improved security.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HuggingFaceSecretReference"),
						},
					},
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint is the reference to the inference service to benchmark.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EndpointSpec"),
						},
					},
					"serviceMetadata": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceMetadata records metadata about the backend model server or service being benchmarked. This includes details such as server engine, version, and GPU configuration for filtering experiments.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServiceMetadata"),
						},
					},
					"task": {
						SchemaProps: spec.SchemaProps{
							Description: "Task specifies the task to benchmark, pattern: <input-modality>-to-<output-modality> (e.g., \"text-to-text\", \"image-to-text\").",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"trafficScenarios": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TrafficScenarios contains a list of traffic scenarios to simulate during the benchmark. If not provided, defaults will be assigned via genai-bench.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"numConcurrency": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NumConcurrency defines a list of concurrency levels to test during the benchmark. If not provided, defaults will be assigned via genai-bench.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int32",
									},
								},
							},
						},
					},
					"maxTimePerIteration": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxTimePerIteration specifies the maximum time (in minutes) for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxRequestsPerIteration": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxRequestsPerIteration specifies the maximum number of requests for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"additionalRequestParams": {
						SchemaProps: spec.SchemaProps{
							Description: "AdditionalRequestParams contains additional request parameters as a map.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"dataset": {
						SchemaProps: spec.SchemaProps{
							Description: "Dataset is the dataset used for benchmarking. It is optional and only required for tasks other than \"text-to-<output-modality>\".",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec"),
						},
					},
					"outputLocation": {
						SchemaProps: spec.SchemaProps{
							Description: "OutputLocation specifies where the benchmark results will be stored (e.g., object storage).",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec"),
						},
					},
					"resultFolderName": {
						SchemaProps: spec.SchemaProps{
							Description: "ResultFolderName specifies the name of the folder that stores the benchmark result. A default name will be assigned if not specified.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"podOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "Pod defines the pod configuration for the benchmark job. This is optional, if not provided, default values will be used.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PodOverride"),
						},
					},
				},
				Required: []string{"endpoint", "task", "maxTimePerIteration", "maxRequestsPerIteration", "outputLocation"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EndpointSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HuggingFaceSecretReference", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PodOverride", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServiceMetadata", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec"},
	}
}

func schema_pkg_apis_ome_v1beta1_BenchmarkJobStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BenchmarkJobStatus reflects the state and results of the benchmark job. It will be set and updated by the controller.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "State represents the current state of the benchmark job: \"Pending\", \"Running\", \"Completed\", \"Failed\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"startTime": {
						SchemaProps: spec.SchemaProps{
							Description: "StartTime is the timestamp for when the benchmark job started.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"completionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletionTime is the timestamp for when the benchmark job completed, either successfully or unsuccessfully.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastReconcileTime": {
						SchemaProps: spec.SchemaProps{
							Description: "LastReconcileTime is the timestamp for the last time the job was reconciled by the controller.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"failureMessage": {
						SchemaProps: spec.SchemaProps{
							Description: "FailureMessage contains any error messages if the benchmark job failed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"details": {
						SchemaProps: spec.SchemaProps{
							Description: "Details provide additional information or metadata about the benchmark job.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"state"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_BodyFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BodyFilter defines body content filtering rules.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type defines the filter type.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pattern": {
						SchemaProps: spec.SchemaProps{
							Description: "Pattern defines the pattern to match.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"action": {
						SchemaProps: spec.SchemaProps{
							Description: "Action defines the filtering action.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"replacement": {
						SchemaProps: spec.SchemaProps{
							Description: "Replacement defines the replacement value for redaction.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type", "action"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_BuiltinPermissionProfile(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BuiltinPermissionProfile defines a built-in permission profile.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the built-in permission profile.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_CircuitBreakerConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CircuitBreakerConfig defines circuit breaker configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"failureThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "FailureThreshold is the number of consecutive failures to open the circuit.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"successThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "SuccessThreshold is the number of consecutive successes to close the circuit.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"openStateTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "OpenStateTimeout is the time to wait before transitioning to half-open.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"maxRequestsHalfOpen": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxRequestsHalfOpen is the maximum requests allowed in half-open state.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"requestTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestTimeout defines the timeout for requests in various states.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"errorRateThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "ErrorRateThreshold defines the error rate percentage to open the circuit.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"minRequestsThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "MinRequestsThreshold is the minimum requests before error rate is calculated.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClientCertCredentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClientCertCredentials defines client certificate authentication.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"certificateRef": {
						SchemaProps: spec.SchemaProps{
							Description: "CertificateRef references the client certificate secret.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"privateKeyRef": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivateKeyRef references the private key secret.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"caRef": {
						SchemaProps: spec.SchemaProps{
							Description: "CARef references the CA certificate secret for verification.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"verifyServerCert": {
						SchemaProps: spec.SchemaProps{
							Description: "VerifyServerCert controls whether to verify the server certificate.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"certificateRef", "privateKeyRef"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterBaseModel(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterBaseModel is the Schema for the basemodels API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BaseModelSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterBaseModelList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterBaseModelList contains a list of ClusterBaseModel",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterBaseModel"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterBaseModel", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterMCPGateway(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterMCPGateway is the cluster-scoped Schema for the mcpgateways API. ClusterMCPGateway provides AI-aware routing, context management, and federation capabilities for Model Context Protocol (MCP) servers across the entire cluster.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewaySpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewaySpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterMCPGatewayList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterMCPGatewayList contains a list of ClusterMCPGateway.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPGateway"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPGateway", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterMCPServer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterMCPServer is the cluster-scoped Schema for the mcpservers API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerStatus"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterMCPServerList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterMCPServerList contains a list of ClusterMCPServer",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPServer"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterMCPServer", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterServingRuntime(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterServingRuntime is the Schema for the servingruntimes API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ClusterServingRuntimeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ClusterServingRuntimeList contains a list of ServingRuntime",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterServingRuntime"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ClusterServingRuntime", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ComplianceConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ComplianceConfig defines compliance-related policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"dataRetention": {
						SchemaProps: spec.SchemaProps{
							Description: "DataRetention defines data retention policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DataRetentionConfig"),
						},
					},
					"piiDetection": {
						SchemaProps: spec.SchemaProps{
							Description: "PIIDetection defines PII detection and handling.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIDetectionConfig"),
						},
					},
					"encryption": {
						SchemaProps: spec.SchemaProps{
							Description: "Encryption defines encryption requirements.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceEncryptionConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceEncryptionConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DataRetentionConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIDetectionConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_ComplianceEncryptionConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ComplianceEncryptionConfig defines compliance encryption configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requireEncryption": {
						SchemaProps: spec.SchemaProps{
							Description: "RequireEncryption controls whether encryption is required.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"encryptionAtRest": {
						SchemaProps: spec.SchemaProps{
							Description: "EncryptionAtRest controls whether data must be encrypted at rest.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"encryptionInTransit": {
						SchemaProps: spec.SchemaProps{
							Description: "EncryptionInTransit controls whether data must be encrypted in transit.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ComponentExtensionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ComponentExtensionSpec defines the deployment configuration for a given InferenceService component",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum number of replicas for autoscaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleMetric": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"canaryTrafficPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxUnavailable specifies how many component pods can be unavailable",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"deploymentStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
							Ref:         ref("k8s.io/api/apps/v1.DeploymentStrategy"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "k8s.io/api/apps/v1.DeploymentStrategy", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_ome_v1beta1_ComponentStatusSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ComponentStatusSpec describes the state of the component",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"latestReadyRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "Latest revision name that is in ready state",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestCreatedRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "Latest revision name that is created",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"previousRolledoutRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "Previous revision name that is rolled out with 100 percent traffic",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"latestRolledoutRevision": {
						SchemaProps: spec.SchemaProps{
							Description: "Latest revision name that is rolled out with 100 percent traffic",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"traffic": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Traffic holds the configured traffic distribution for latest ready revision and previous rolled out revision.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"),
									},
								},
							},
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the primary url that will distribute traffic over the provided traffic targets. This will be one the REST or gRPC endpoints that are available. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"restURL": {
						SchemaProps: spec.SchemaProps{
							Description: "REST endpoint of the component if available.",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Addressable endpoint for the InferenceService",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
					"selectedAccelerator": {
						SchemaProps: spec.SchemaProps{
							Description: "SelectedAccelerator shows which AcceleratorClass was selected",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelection"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelection", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.Addressable", "knative.dev/serving/pkg/apis/serving/v1.TrafficTarget"},
	}
}

func schema_pkg_apis_ome_v1beta1_ConfigValidationError(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigValidationError represents a configuration validation error.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"field": {
						SchemaProps: spec.SchemaProps{
							Description: "Field is the configuration field that failed validation.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Message describes the validation error.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"severity": {
						SchemaProps: spec.SchemaProps{
							Description: "Severity indicates the error severity.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"field", "message", "severity"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ConfigValidationStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ConfigValidationStatus provides configuration validation status.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"valid": {
						SchemaProps: spec.SchemaProps{
							Description: "Valid indicates whether the current configuration is valid.",
							Default:     false,
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"validationErrors": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ValidationErrors contains any configuration validation errors.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationError"),
									},
								},
							},
						},
					},
					"warnings": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Warnings contains non-blocking configuration warnings.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"lastValidated": {
						SchemaProps: spec.SchemaProps{
							Description: "LastValidated is when the configuration was last validated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
				Required: []string{"valid"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationError", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_CredentialRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CredentialRef provides a reference to a secret containing authentication credentials.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"secretRef": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretRef references a Kubernetes secret containing the credential.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"value": {
						SchemaProps: spec.SchemaProps{
							Description: "Value contains the credential value directly (not recommended for sensitive data).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"headerName": {
						SchemaProps: spec.SchemaProps{
							Description: "HeaderName specifies the header name for API key authentication.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_ome_v1beta1_CustomMetric(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CustomMetric defines a custom metric to collect.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is the metric name.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type defines the metric type.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"help": {
						SchemaProps: spec.SchemaProps{
							Description: "Help provides a description of the metric.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"labels": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Labels define metric labels.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"name", "type"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_DataRetentionConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DataRetentionConfig defines data retention policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"auditLogRetention": {
						SchemaProps: spec.SchemaProps{
							Description: "AuditLogRetention defines how long to keep audit logs.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"contextRetention": {
						SchemaProps: spec.SchemaProps{
							Description: "ContextRetention defines how long to keep context data.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"sessionRetention": {
						SchemaProps: spec.SchemaProps{
							Description: "SessionRetention defines how long to keep session data.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_DecoderSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "DecoderSpec defines the configuration for the Decoder component (token generation in PD-disaggregated deployment) Used specifically for prefill-decode disaggregated deployments to handle the token generation phase. Similar to EngineSpec in structure, it allows for detailed pod and container configuration, but is specifically used for the decode phase when separating prefill and decode processes.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum number of replicas for autoscaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleMetric": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"canaryTrafficPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxUnavailable specifies how many component pods can be unavailable",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"deploymentStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
							Ref:         ref("k8s.io/api/apps/v1.DeploymentStrategy"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
					"runner": {
						SchemaProps: spec.SchemaProps{
							Description: "Runner container override for customizing the main container This is essentially a container spec that can override the default container Defines the main decoder container configuration, including image, resource requests/limits, environment variables, and command.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec"),
						},
					},
					"leader": {
						SchemaProps: spec.SchemaProps{
							Description: "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed token generation in multi-node deployments.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LeaderSpec"),
						},
					},
					"worker": {
						SchemaProps: spec.SchemaProps{
							Description: "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed token generation tasks as directed by the leader.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec"),
						},
					},
					"acceleratorOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorOverride allows overriding the global accelerator selection for this component",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LeaderSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec", "k8s.io/api/apps/v1.DeploymentStrategy", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_ome_v1beta1_ElicitationPolicyConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ElicitationPolicyConfig defines server-to-client elicitation request policy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether servers can request elicitation from clients.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"requireConfirmation": {
						SchemaProps: spec.SchemaProps{
							Description: "RequireConfirmation controls whether user confirmation is required for elicitation.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"allowedTypes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AllowedTypes defines which types of elicitation are allowed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout defines the maximum time to wait for elicitation responses.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"maxConcurrentRequests": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxConcurrentRequests is the maximum concurrent elicitation requests.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_Endpoint(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Endpoint defines a direct URL-based inference service with additional API configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL represents the endpoint URL for the inference service.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiFormat": {
						SchemaProps: spec.SchemaProps{
							Description: "APIFormat specifies the type of API, such as \"openai\" or \"oci-cohere\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelName": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelName specifies the name of the model being served at the endpoint. Useful for endpoints that require model-specific configuration. For instance, for openai API, this is a required field in the payload",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"url", "apiFormat"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_EndpointSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EndpointSpec defines a reference to an inference service. It supports either a Kubernetes-style reference (InferenceService) or an Endpoint struct for a direct URL. Cross-namespace references are supported for InferenceService but require appropriate RBAC permissions to access resources in the target namespace.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"inferenceService": {
						SchemaProps: spec.SchemaProps{
							Description: "InferenceService holds a Kubernetes reference to an internal inference service.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceReference"),
						},
					},
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint holds the details of a direct endpoint for an external inference service, including URL and API details.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.Endpoint"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.Endpoint", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceReference"},
	}
}

func schema_pkg_apis_ome_v1beta1_EngineSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EngineSpec defines the configuration for the Engine component (can be used for both single-node and multi-node deployments) Provides a comprehensive specification for deploying model serving containers and pods. It allows for complete Kubernetes pod configuration including main containers, init containers, sidecars, volumes, and other pod-level settings. For distributed deployments, it supports leader-worker architecture configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum number of replicas for autoscaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleMetric": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"canaryTrafficPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxUnavailable specifies how many component pods can be unavailable",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"deploymentStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
							Ref:         ref("k8s.io/api/apps/v1.DeploymentStrategy"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
					"runner": {
						SchemaProps: spec.SchemaProps{
							Description: "Runner container override for customizing the engine container This is essentially a container spec that can override the default container Defines the main model runner container configuration, including image, resource requests/limits, environment variables, and command.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec"),
						},
					},
					"leader": {
						SchemaProps: spec.SchemaProps{
							Description: "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed inference in multi-node deployments.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LeaderSpec"),
						},
					},
					"worker": {
						SchemaProps: spec.SchemaProps{
							Description: "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed processing tasks as directed by the leader.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec"),
						},
					},
					"acceleratorOverride": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorOverride allows overriding the global accelerator selection for this component",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LeaderSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec", "k8s.io/api/apps/v1.DeploymentStrategy", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_ome_v1beta1_FailureInfo(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"location": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of component to which the failure relates (usually Pod name)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"reason": {
						SchemaProps: spec.SchemaProps{
							Description: "High level class of failure",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Detailed error message",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelRevisionName": {
						SchemaProps: spec.SchemaProps{
							Description: "Internal Revision/ID of model, tied to specific Spec contents",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"time": {
						SchemaProps: spec.SchemaProps{
							Description: "Time failure occurred or was discovered",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"exitCode": {
						SchemaProps: spec.SchemaProps{
							Description: "Exit status from the last termination of the container",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_FineTunedWeight(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FineTunedWeight is the Schema for the finetunedweights API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeightSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeightSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatusSpec", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_FineTunedWeightList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FineTunedWeightList contains a list of FineTunedWeight",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeight"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FineTunedWeight", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_FineTunedWeightSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FineTunedWeightSpec defines the desired state of FineTunedWeight",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"baseModelRef": {
						SchemaProps: spec.SchemaProps{
							Description: "Reference to the base model that this weight is fine-tuned from",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ObjectReference"),
						},
					},
					"modelType": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelType of the fine-tuned weight, e.g., \"Distillation\", \"Adapter\", \"Tfew\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hyperParameters": {
						SchemaProps: spec.SchemaProps{
							Description: "HyperParameters used for fine-tuning, stored as generic JSON for flexibility",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"displayName": {
						SchemaProps: spec.SchemaProps{
							Description: "DisplayName is the user-friendly name of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"disabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the model is enabled or not",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"vendor": {
						SchemaProps: spec.SchemaProps{
							Description: "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"compartmentID": {
						SchemaProps: spec.SchemaProps{
							Description: "CompartmentID is the compartment ID of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"configuration": {
						SchemaProps: spec.SchemaProps{
							Description: "Configuration of the fine-tuned weight, stored as generic JSON for flexibility",
							Ref:         ref("k8s.io/apimachinery/pkg/runtime.RawExtension"),
						},
					},
					"storage": {
						SchemaProps: spec.SchemaProps{
							Description: "Storage configuration for the fine-tuned weight",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec"),
						},
					},
					"trainingJobRef": {
						SchemaProps: spec.SchemaProps{
							Description: "TrainingJobID is the ID of the training job that produced this weight",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ObjectReference"),
						},
					},
				},
				Required: []string{"baseModelRef", "modelType", "hyperParameters", "storage"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ObjectReference", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageSpec", "k8s.io/apimachinery/pkg/runtime.RawExtension"},
	}
}

func schema_pkg_apis_ome_v1beta1_GRPCTransportConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GRPCTransportConfig defines gRPC transport configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the gRPC port.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxMessageSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxMessageSize defines the maximum message size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"connectionTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "ConnectionTimeout defines the connection timeout.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayIngressConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayIngressConfig defines ingress configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether ingress is created.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"className": {
						SchemaProps: spec.SchemaProps{
							Description: "ClassName defines the ingress class name.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hosts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Hosts define the ingress hosts.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressHost"),
									},
								},
							},
						},
					},
					"tls": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TLS defines TLS configuration for ingress.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressTLS"),
									},
								},
							},
						},
					},
					"annotations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Annotations define ingress annotations.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressHost", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressTLS"},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayIngressHost(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayIngressHost defines an ingress host.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"host": {
						SchemaProps: spec.SchemaProps{
							Description: "Host is the host name.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"paths": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Paths define the host paths.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressPath"),
									},
								},
							},
						},
					},
				},
				Required: []string{"host"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressPath"},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayIngressPath(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayIngressPath defines an ingress path.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is the URL path.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathType": {
						SchemaProps: spec.SchemaProps{
							Description: "PathType defines the path type.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceName is the backend service name.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"servicePort": {
						SchemaProps: spec.SchemaProps{
							Description: "ServicePort is the backend service port.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"path", "serviceName", "servicePort"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayIngressTLS(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayIngressTLS defines ingress TLS configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hosts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Hosts define the TLS hosts.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"secretName": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretName references the TLS secret.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayMetrics(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayMetrics provides real-time performance metrics for the gateway.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requestsPerSecond": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerSecond is the current requests per second rate.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"p50Latency": {
						SchemaProps: spec.SchemaProps{
							Description: "P50Latency is the 50th percentile latency in milliseconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"p90Latency": {
						SchemaProps: spec.SchemaProps{
							Description: "P90Latency is the 99th percentile latency in milliseconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"errorRate": {
						SchemaProps: spec.SchemaProps{
							Description: "ErrorRate is the current error rate as a percentage.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"activeConnections": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveConnections is the number of currently active connections.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"cacheHitRate": {
						SchemaProps: spec.SchemaProps{
							Description: "CacheHitRate is the cache hit rate as a percentage.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"toolInvocations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ToolInvocations tracks tool invocation statistics.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: 0,
										Type:    []string{"integer"},
										Format:  "int64",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayServiceConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayServiceConfig defines service configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type defines the service type.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Ports define the service ports.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServicePort"),
									},
								},
							},
						},
					},
					"annotations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Annotations define service annotations.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServicePort"},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayServicePort(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayServicePort defines a service port.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is the port name.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port is the service port.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"targetPort": {
						SchemaProps: spec.SchemaProps{
							Description: "TargetPort is the target port on pods.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"protocol": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol is the port protocol.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "port"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_GatewayTransportConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayTransportConfig defines transport protocol configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"http": {
						SchemaProps: spec.SchemaProps{
							Description: "HTTP defines HTTP transport configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HTTPTransportConfig"),
						},
					},
					"grpc": {
						SchemaProps: spec.SchemaProps{
							Description: "GRPC defines gRPC transport configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GRPCTransportConfig"),
						},
					},
					"webSocket": {
						SchemaProps: spec.SchemaProps{
							Description: "WebSocket defines WebSocket transport configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WebSocketTransportConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GRPCTransportConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HTTPTransportConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WebSocketTransportConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_HTTPTransportConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HTTPTransportConfig defines HTTP transport configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the HTTP port.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadTimeout defines the HTTP read timeout.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"writeTimeout": {
						SchemaProps: spec.SchemaProps{
							Description: "WriteTimeout defines the HTTP write timeout.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"maxHeaderSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxHeaderSize defines the maximum header size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_HeaderFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HeaderFilter defines header filtering rules.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is the header name to filter.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"action": {
						SchemaProps: spec.SchemaProps{
							Description: "Action defines the filtering action.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pattern": {
						SchemaProps: spec.SchemaProps{
							Description: "Pattern is a regex pattern to match header values.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "action"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_HealthCheckConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HealthCheckConfig defines health checking configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether health checking is performed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Description: "Interval is the time between health checks.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout is the maximum time to wait for a health check response.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"unhealthyThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "UnhealthyThreshold is the number of consecutive failures before marking unhealthy.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"healthyThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "HealthyThreshold is the number of consecutive successes before marking healthy.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_HealthEndpointConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HealthEndpointConfig defines health check endpoint configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether health endpoints are exposed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the health endpoint port.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"livenessPath": {
						SchemaProps: spec.SchemaProps{
							Description: "LivenessPath defines the liveness probe path.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"readinessPath": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadinessPath defines the readiness probe path.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_HostedMCPServer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HostedMCPServer defines a server that runs as pods in the cluster.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"podSpec": {
						SchemaProps: spec.SchemaProps{
							Description: "PodSpec defines the pod template to use for the MCP server.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the number of desired replicas for the server. Only applicable for servers with network-based transports (e.g., http, sse).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"podSpec"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.PodTemplateSpec"},
	}
}

func schema_pkg_apis_ome_v1beta1_HuggingFaceSecretReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HuggingFaceSecretReference defines a reference to a Kubernetes Secret containing the Hugging Face API key. This secret must reside in the same namespace as the BenchmarkJob. Cross-namespace references are not allowed for security and simplicity.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the secret containing the Hugging Face API key. The secret must reside in the same namespace as the BenchmarkJob.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_InferenceService(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InferenceService is the Schema for the InferenceServices API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceServiceStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_InferenceServiceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InferenceServiceList contains a list of Service",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceService"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InferenceService", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_InferenceServiceReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InferenceServiceReference defines the reference to a Kubernetes inference service.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name specifies the name of the inference service to benchmark.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace specifies the Kubernetes namespace where the inference service is deployed. Cross-namespace references are allowed but require appropriate RBAC permissions.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"name", "namespace"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_InferenceServiceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InferenceServiceSpec is the top level type for this resource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"predictor": {
						SchemaProps: spec.SchemaProps{
							Description: "Predictor defines the model serving spec It specifies how the model should be deployed and served, handling inference requests. Deprecated: Predictor is deprecated and will be removed in a future release. Please use Engine and Model fields instead.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PredictorSpec"),
						},
					},
					"engine": {
						SchemaProps: spec.SchemaProps{
							Description: "Engine defines the serving engine spec This provides detailed container and pod specifications for model serving. It allows defining the model runner (container spec), as well as complete pod specifications including init containers, sidecar containers, and other pod-level configurations. Engine can also be configured for multi-node deployments using leader and worker specifications.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EngineSpec"),
						},
					},
					"decoder": {
						SchemaProps: spec.SchemaProps{
							Description: "Decoder defines the decoder spec This is specifically used for PD (Prefill-Decode) disaggregated serving deployments. Similar to Engine in structure, it allows for container and pod specifications, but is only utilized when implementing the disaggregated serving pattern to separate the prefill and decode phases of inference.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DecoderSpec"),
						},
					},
					"model": {
						SchemaProps: spec.SchemaProps{
							Description: "Model defines the model to be used for inference, referencing either a BaseModel or a custom model. This allows models to be managed independently of the serving configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRef"),
						},
					},
					"runtime": {
						SchemaProps: spec.SchemaProps{
							Description: "Runtime defines the serving runtime environment that will be used to execute the model. It is an inference service spec template that determines how the service should be deployed. Runtime is optional - if not defined, the operator will automatically select the best runtime based on the model's size, architecture, format, quantization, and framework.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeRef"),
						},
					},
					"router": {
						SchemaProps: spec.SchemaProps{
							Description: "Router defines the router spec",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RouterSpec"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "KedaConfig defines the autoscaling configuration for KEDA Provides settings for event-driven autoscaling using KEDA (Kubernetes Event-driven Autoscaling), allowing the service to scale based on custom metrics or event sources.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
					"acceleratorSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorSelector specifies accelerator selection preferences",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorSelector", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DecoderSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EngineSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRef", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PredictorSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RouterSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeRef"},
	}
}

func schema_pkg_apis_ome_v1beta1_InferenceServiceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InferenceServiceStatus defines the observed state of InferenceService",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("knative.dev/pkg/apis.Condition"),
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"address": {
						SchemaProps: spec.SchemaProps{
							Description: "Addressable endpoint for the InferenceService",
							Ref:         ref("knative.dev/pkg/apis/duck/v1.Addressable"),
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
							Ref:         ref("knative.dev/pkg/apis.URL"),
						},
					},
					"components": {
						SchemaProps: spec.SchemaProps{
							Description: "Statuses for the components of the InferenceService",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComponentStatusSpec"),
									},
								},
							},
						},
					},
					"modelStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "Model related statuses",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComponentStatusSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelStatus", "knative.dev/pkg/apis.Condition", "knative.dev/pkg/apis.URL", "knative.dev/pkg/apis/duck/v1.Addressable"},
	}
}

func schema_pkg_apis_ome_v1beta1_InlineAuthzConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InlineAuthzConfig contains an embedded authorization policy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"policies": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Policies is a list of Cedar policy strings.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"entitiesJSON": {
						SchemaProps: spec.SchemaProps{
							Description: "EntitiesJSON is a JSON string representing Cedar entities.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"policies"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_InlineOIDCConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "InlineOIDCConfig contains direct OIDC provider configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"issuer": {
						SchemaProps: spec.SchemaProps{
							Description: "Issuer is the OIDC issuer URL.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"audience": {
						SchemaProps: spec.SchemaProps{
							Description: "Audience is the expected audience for the token.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"jwksURL": {
						SchemaProps: spec.SchemaProps{
							Description: "JWKSURL is the URL to fetch the JSON Web Key Set from. If empty, OIDC discovery will be used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"issuer"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_JWTCredentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "JWTCredentials defines JWT authentication credentials.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"signingKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SigningKey references the JWT signing key secret.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"algorithm": {
						SchemaProps: spec.SchemaProps{
							Description: "Algorithm defines the JWT signing algorithm.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"issuer": {
						SchemaProps: spec.SchemaProps{
							Description: "Issuer defines the expected JWT issuer.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"audience": {
						SchemaProps: spec.SchemaProps{
							Description: "Audience defines the expected JWT audience.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"expirationTolerance": {
						SchemaProps: spec.SchemaProps{
							Description: "ExpirationTolerance defines tolerance for token expiration.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
				Required: []string{"signingKey"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_KedaConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KedaConfig stores the configuration settings for KEDA autoscaling within the InferenceService. It includes fields like the Prometheus server address, custom query, scaling threshold, and operator.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enableKeda": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableKeda determines whether KEDA autoscaling is enabled for the InferenceService. - true: KEDA will manage the autoscaling based on the provided configuration. - false: KEDA will not be used, and autoscaling will rely on other mechanisms (e.g., HPA).",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"promServerAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "PromServerAddress specifies the address of the Prometheus server that KEDA will query to retrieve metrics for autoscaling decisions. This should be a fully qualified URL, including the protocol and port number.\n\nExample:\n  http://prometheus-operated.monitoring.svc.cluster.local:9090",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"customPromQuery": {
						SchemaProps: spec.SchemaProps{
							Description: "CustomPromQuery defines a custom Prometheus query that KEDA will execute to evaluate the desired metric for scaling. This query should return a single numerical value that represents the metric to be monitored.\n\nExample:\n  avg_over_time(http_requests_total{service=\"llama\"}[5m])",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scalingThreshold": {
						SchemaProps: spec.SchemaProps{
							Description: "ScalingThreshold sets the numerical threshold against which the result of the Prometheus query will be compared. Depending on the ScalingOperator, this threshold determines when to scale the number of replicas up or down.\n\nExample:\n  \"10\" - The Autoscaler will compare the metric value to 10.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scalingOperator": {
						SchemaProps: spec.SchemaProps{
							Description: "ScalingOperator specifies the comparison operator used by KEDA to decide whether to scale the Deployment. Common operators include: - \"GreaterThanOrEqual\": Scale up when the metric is >= ScalingThreshold. - \"LessThanOrEqual\": Scale down when the metric is <= ScalingThreshold.\n\nThis operator defines the condition under which scaling actions are triggered based on the evaluated metric.\n\nExample:\n  \"GreaterThanOrEqual\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_KubeResourcePermission(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KubeResourcePermission defines permissions for a set of Kubernetes resources.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"apiGroups": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "APIGroups is the list of API groups. \"*\" means all.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"resources": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources is the list of resource names. \"*\" means all.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"verbs": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Verbs is the list of allowed verbs.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"apiGroups", "resources", "verbs"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_KubernetesOIDCConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KubernetesOIDCConfig configures OIDC for Kubernetes service account token validation.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"issuer": {
						SchemaProps: spec.SchemaProps{
							Description: "Issuer is the OIDC issuer URL of the Kubernetes cluster. If not specified, it defaults to the cluster's issuer URL.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_LeaderSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LeaderSpec defines the configuration for a leader node in a multi-node component The leader node coordinates the activities of worker nodes in distributed inference or token generation setups, handling task distribution and result aggregation.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"runner": {
						SchemaProps: spec.SchemaProps{
							Description: "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the leader node's coordination logic.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_LogFileConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LogFileConfig defines file-based logging configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path defines the log file path.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxSize defines the maximum log file size before rotation.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"maxFiles": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxFiles defines the maximum number of log files to keep.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"compress": {
						SchemaProps: spec.SchemaProps{
							Description: "Compress controls whether rotated logs are compressed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
				Required: []string{"path"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_LoggingConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "LoggingConfig defines structured logging configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"level": {
						SchemaProps: spec.SchemaProps{
							Description: "Level defines the logging level.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"format": {
						SchemaProps: spec.SchemaProps{
							Description: "Format defines the log format.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"output": {
						SchemaProps: spec.SchemaProps{
							Description: "Output defines where logs are sent.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"file": {
						SchemaProps: spec.SchemaProps{
							Description: "File defines file-based logging configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LogFileConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LogFileConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPAuthenticationConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPAuthenticationConfig defines simplified client authentication configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether authentication is required.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"methods": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Methods define the supported authentication methods in order of preference.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig"),
									},
								},
							},
						},
					},
					"default": {
						SchemaProps: spec.SchemaProps{
							Description: "Default provides the default authentication method when none is specified.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPCapabilities(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPCapabilities defines the features supported by the MCP server.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tools": {
						SchemaProps: spec.SchemaProps{
							Description: "Tools indicates whether the server supports tool execution.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Resources indicates whether the server supports exposing resources.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"prompts": {
						SchemaProps: spec.SchemaProps{
							Description: "Prompts indicates whether the server supports prompt elicitation.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGateway(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPGateway is the Schema for the mcpgateways API. MCPGateway provides AI-aware routing, context management, and federation capabilities for Model Context Protocol (MCP) servers and tools.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewaySpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewaySpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPGatewayList contains a list of MCPGateway.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGateway"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGateway", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayNetworkConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayNetworkConfig defines service exposure, transport protocols, and ingress settings.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"service": {
						SchemaProps: spec.SchemaProps{
							Description: "Service defines the service configuration for the gateway.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServiceConfig"),
						},
					},
					"transport": {
						SchemaProps: spec.SchemaProps{
							Description: "Transport defines the transport protocol configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayTransportConfig"),
						},
					},
					"ingress": {
						SchemaProps: spec.SchemaProps{
							Description: "Ingress defines ingress configuration for external access.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayIngressConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayServiceConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayTransportConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayObservabilityConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ObservabilityConfig defines monitoring, metrics, and tracing configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metrics": {
						SchemaProps: spec.SchemaProps{
							Description: "Metrics defines metrics collection and export configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MetricsConfig"),
						},
					},
					"tracing": {
						SchemaProps: spec.SchemaProps{
							Description: "Tracing defines distributed tracing configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TracingConfig"),
						},
					},
					"logging": {
						SchemaProps: spec.SchemaProps{
							Description: "Logging defines structured logging configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LoggingConfig"),
						},
					},
					"health": {
						SchemaProps: spec.SchemaProps{
							Description: "Health defines health check endpoint configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthEndpointConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthEndpointConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.LoggingConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MetricsConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.TracingConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayPolicyConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GatewayPolicyConfig defines unified security, authentication, authorization, and traffic policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"authentication": {
						SchemaProps: spec.SchemaProps{
							Description: "Authentication defines client authentication configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPAuthenticationConfig"),
						},
					},
					"rateLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "RateLimit defines rate limiting configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitConfig"),
						},
					},
					"circuitBreaker": {
						SchemaProps: spec.SchemaProps{
							Description: "CircuitBreaker defines the circuit breaking configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CircuitBreakerConfig"),
						},
					},
					"audit": {
						SchemaProps: spec.SchemaProps{
							Description: "Audit defines audit logging configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditConfig"),
						},
					},
					"requestFiltering": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestFiltering defines request filtering policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RequestFilteringConfig"),
						},
					},
					"responseFiltering": {
						SchemaProps: spec.SchemaProps{
							Description: "ResponseFiltering defines response filtering policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResponseFilteringConfig"),
						},
					},
					"compliance": {
						SchemaProps: spec.SchemaProps{
							Description: "Compliance defines compliance-related policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceConfig"),
						},
					},
					"sampling": {
						SchemaProps: spec.SchemaProps{
							Description: "Sampling defines server-to-client sampling request policy.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingPolicyConfig"),
						},
					},
					"elicitation": {
						SchemaProps: spec.SchemaProps{
							Description: "Elicitation defines server-to-client elicitation request policy.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ElicitationPolicyConfig"),
						},
					},
					"sessionIsolation": {
						SchemaProps: spec.SchemaProps{
							Description: "SessionIsolation defines session isolation and context boundary policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SessionIsolationConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuditConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CircuitBreakerConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ComplianceConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ElicitationPolicyConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPAuthenticationConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RequestFilteringConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResponseFilteringConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingPolicyConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SessionIsolationConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayServerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPGatewayServerStatus defines the status of a connected MCP server.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name is the name of the MCP server.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace is the namespace of the MCP server.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "State is the current connection state.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastConnected": {
						SchemaProps: spec.SchemaProps{
							Description: "LastConnected is the timestamp of the last successful connection.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"lastError": {
						SchemaProps: spec.SchemaProps{
							Description: "LastError contains the last error encountered.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"requestCount": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestCount is the total number of requests sent to this server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"errorCount": {
						SchemaProps: spec.SchemaProps{
							Description: "ErrorCount is the total number of errors from this server.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"averageResponseTime": {
						SchemaProps: spec.SchemaProps{
							Description: "AverageResponseTime is the average response time in milliseconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"circuitBreakerState": {
						SchemaProps: spec.SchemaProps{
							Description: "CircuitBreakerState is the current circuit breaker state.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"weight": {
						SchemaProps: spec.SchemaProps{
							Description: "Weight is the current effective weight for load balancing.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"tags": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Tags are the current tags associated with this server.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"capabilities": {
						SchemaProps: spec.SchemaProps{
							Description: "Capabilities are the server's current capabilities.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities"),
						},
					},
				},
				Required: []string{"name", "state"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewaySpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPGatewaySpec defines the desired state of MCPGateway. MCPGateway provides AI-aware routing, context management, and orchestration capabilities for Model Context Protocol (MCP) servers with federation support.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the number of desired replicas for the gateway.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"podSpec": {
						SchemaProps: spec.SchemaProps{
							Description: "PodSpec defines the pod template for the gateway deployment.",
							Ref:         ref("k8s.io/api/core/v1.PodTemplateSpec"),
						},
					},
					"mcpServers": {
						SchemaProps: spec.SchemaProps{
							Description: "MCPServers defines how the gateway discovers and connects to MCP servers.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerDiscoveryConfig"),
						},
					},
					"transport": {
						SchemaProps: spec.SchemaProps{
							Description: "Transport defines the supported transport protocols for MCP communication.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"policy": {
						SchemaProps: spec.SchemaProps{
							Description: "Policy defines unified security, authentication, authorization, and traffic policies.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayPolicyConfig"),
						},
					},
					"observability": {
						SchemaProps: spec.SchemaProps{
							Description: "Observability defines monitoring, metrics, and tracing configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayObservabilityConfig"),
						},
					},
					"network": {
						SchemaProps: spec.SchemaProps{
							Description: "Network defines service exposure and ingress settings.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayNetworkConfig"),
						},
					},
					"protocolVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "ProtocolVersion defines MCP protocol version constraints and negotiation settings.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPProtocolVersionConfig"),
						},
					},
				},
				Required: []string{"mcpServers"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayNetworkConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayObservabilityConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayPolicyConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPProtocolVersionConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerDiscoveryConfig", "k8s.io/api/core/v1.PodTemplateSpec"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPGatewayStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPGatewayStatus defines the observed state of MCPGateway.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"type",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions represent the latest available observations of the MCPGateway's state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Phase is the current phase of the MCPGateway lifecycle.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration reflects the generation most recently observed by the controller.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the most recently observed number of replicas.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadyReplicas is the number of ready replicas.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"availableReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "AvailableReplicas is the number of available replicas.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"activeSessions": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveSessions is the current number of active sessions.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"totalRequests": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalRequests is the total number of requests processed.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"totalErrors": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalErrors is the total number of errors encountered.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"averageLatency": {
						SchemaProps: spec.SchemaProps{
							Description: "AverageLatency is the average request latency in milliseconds.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"connectedServers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ConnectedServers is the list of currently connected servers.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayServerStatus"),
									},
								},
							},
						},
					},
					"serverStatusSummary": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerStatusSummary provides an aggregated summary of server statuses.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServerStatusSummary"),
						},
					},
					"unhealthyServers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "UnhealthyServers lists servers that are currently unhealthy.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayServerStatus"),
									},
								},
							},
						},
					},
					"serviceURL": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceURL is the URL where the gateway service can be accessed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastUpdateTime": {
						SchemaProps: spec.SchemaProps{
							Description: "LastUpdateTime is the last time the status was updated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"metrics": {
						SchemaProps: spec.SchemaProps{
							Description: "Metrics provides real-time performance metrics.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayMetrics"),
						},
					},
					"configStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigStatus provides configuration validation status.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationStatus"),
						},
					},
					"resourceUsage": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourceUsage provides current resource utilization information.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceUsageStatus"),
						},
					},
					"toolRegistry": {
						SchemaProps: spec.SchemaProps{
							Description: "ToolRegistry provides status of the tool registry.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ToolRegistryStatus"),
						},
					},
					"resourceRegistry": {
						SchemaProps: spec.SchemaProps{
							Description: "ResourceRegistry provides status of the resource registry.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceRegistryStatus"),
						},
					},
					"promptRegistry": {
						SchemaProps: spec.SchemaProps{
							Description: "PromptRegistry provides status of the prompt registry.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PromptRegistryStatus"),
						},
					},
					"workflowStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "WorkflowStatus provides status of workflow orchestration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkflowStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ConfigValidationStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.GatewayMetrics", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPGatewayServerStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PromptRegistryStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceRegistryStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ResourceUsageStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServerStatusSummary", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ToolRegistryStatus", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkflowStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.Condition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPProtocolVersionConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPProtocolVersionConfig defines MCP protocol version constraints and negotiation settings.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"supported": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Supported defines the list of supported MCP protocol versions. If empty, the gateway will support all known versions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "MinVersion defines the minimum acceptable MCP protocol version.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxVersion defines the maximum acceptable MCP protocol version.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"preferredVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "PreferredVersion defines the preferred protocol version for new connections.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"allowVersionNegotiation": {
						SchemaProps: spec.SchemaProps{
							Description: "AllowVersionNegotiation controls whether version negotiation is allowed.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"strictVersioning": {
						SchemaProps: spec.SchemaProps{
							Description: "StrictVersioning controls whether to reject connections with unsupported versions.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServer is the Schema for the mcpservers API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerStatus"),
						},
					},
				},
				Required: []string{"spec"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServerDiscoveryConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServerDiscoveryConfig defines how the gateway discovers and connects to MCP servers.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"static": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Static provides a fixed list of MCP server references.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerRef"),
									},
								},
							},
						},
					},
					"selector": {
						SchemaProps: spec.SchemaProps{
							Description: "Selector allows dynamic discovery of MCPServer resources using a label selector.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"namespaceSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NamespaceSelector restricts server discovery to specific namespaces. Only applicable when using Selector. If empty, searches all accessible namespaces.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"),
						},
					},
					"autoDiscovery": {
						SchemaProps: spec.SchemaProps{
							Description: "AutoDiscovery enables automatic discovery of MCP servers through federation.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"healthCheck": {
						SchemaProps: spec.SchemaProps{
							Description: "HealthCheck defines health checking configuration for discovered servers.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthCheckConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HealthCheckConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServerRef", "k8s.io/apimachinery/pkg/apis/meta/v1.LabelSelector"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServerList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServerList contains a list of MCPServer",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServer"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPServer", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServerRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServerRef defines a reference to an upstream MCP server with routing parameters.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referenced MCPServer resource.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the referenced MCPServer resource. If empty, assumes the gateway's namespace.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority for server selection (lower value is higher priority).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"tags": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Tags define semantic tags for routing decisions.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"capabilities": {
						SchemaProps: spec.SchemaProps{
							Description: "Capabilities override the server's advertised capabilities for routing.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities"),
						},
					},
					"auth": {
						SchemaProps: spec.SchemaProps{
							Description: "Auth defines the credentials for this specific server.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig"),
						},
					},
					"transport": {
						SchemaProps: spec.SchemaProps{
							Description: "Transport override for this specific server.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServerSpec defines the desired state of an MCPServer. An MCPServer can either be 'Hosted' within the cluster or a 'Remote' external service.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hosted": {
						SchemaProps: spec.SchemaProps{
							Description: "Hosted defines a server that runs as pods within the cluster.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HostedMCPServer"),
						},
					},
					"remote": {
						SchemaProps: spec.SchemaProps{
							Description: "Remote defines a server that is accessed via an external URL.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RemoteMCPServer"),
						},
					},
					"transport": {
						SchemaProps: spec.SchemaProps{
							Description: "Transport specifies the transport protocol for MCP communication.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"capabilities": {
						SchemaProps: spec.SchemaProps{
							Description: "Capabilities defines the features supported by this server.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities"),
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version of the MCP server software.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"permissionProfile": {
						SchemaProps: spec.SchemaProps{
							Description: "PermissionProfile defines the operational permissions for the server.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSource"),
						},
					},
					"oidcConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "OIDCConfig defines OIDC authentication for authenticating clients.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OIDCConfigSource"),
						},
					},
					"authzConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "AuthzConfig defines authorization policies for the server.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthzConfigSource"),
						},
					},
					"toolsFilter": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ToolsFilter restricts the tools exposed by this server.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AuthzConfigSource", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HostedMCPServer", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.MCPCapabilities", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.OIDCConfigSource", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSource", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RemoteMCPServer"},
	}
}

func schema_pkg_apis_ome_v1beta1_MCPServerStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MCPServerStatus defines the observed state of MCPServer",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"type",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions represent the latest available observations of the MCPServer's state Standard condition types: Ready, Available, Progressing",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.Condition"),
									},
								},
							},
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the URL where the MCP server can be accessed For Hosted servers, this is the cluster-internal or external service URL For Remote servers, this reflects the configured external URL",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"phase": {
						SchemaProps: spec.SchemaProps{
							Description: "Phase is the current phase of the MCPServer lifecycle",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"message": {
						SchemaProps: spec.SchemaProps{
							Description: "Message provides additional information about the current phase",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"observedGeneration": {
						SchemaProps: spec.SchemaProps{
							Description: "ObservedGeneration reflects the generation most recently observed by the controller",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the most recently observed number of replicas for hosted servers",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readyReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadyReplicas is the number of ready replicas for hosted servers",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lastUpdateTime": {
						SchemaProps: spec.SchemaProps{
							Description: "LastUpdateTime is the last time the status was updated",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Condition", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_MetricsConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MetricsConfig defines metrics collection and export configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether metrics collection is active.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the metrics endpoint port.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path defines the metrics endpoint path.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"format": {
						SchemaProps: spec.SchemaProps{
							Description: "Format defines the metrics format.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"customMetrics": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "CustomMetrics define additional custom metrics to collect.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CustomMetric"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CustomMetric"},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelCopies(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"failedCopies": {
						SchemaProps: spec.SchemaProps{
							Description: "How many copies of this predictor's models failed to load recently",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"totalCopies": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number copies of this predictor's models that are currently loaded",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"failedCopies"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelExtensionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"displayName": {
						SchemaProps: spec.SchemaProps{
							Description: "DisplayName is the user-friendly name of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"disabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the model is enabled or not",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"vendor": {
						SchemaProps: spec.SchemaProps{
							Description: "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"compartmentID": {
						SchemaProps: spec.SchemaProps{
							Description: "CompartmentID is the compartment ID of the model",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelFormat(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the format in which the model is stored, e.g., \"ONNX\", \"TensorFlow SavedModel\", \"PyTorch\", \"SafeTensors\"",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"operator": {
						SchemaProps: spec.SchemaProps{
							Description: "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFormat version",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"weight": {
						SchemaProps: spec.SchemaProps{
							Description: "Weight of the model format in the runtime selector, used to prioritize modelFormat",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelFrameworkSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the library in which the model is stored, e.g., \"ONNXRuntime\", \"TensorFlow\", \"PyTorch\", \"Transformer\", \"TensorRTLLM\"",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version of the library. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"operator": {
						SchemaProps: spec.SchemaProps{
							Description: "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFramework version",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"weight": {
						SchemaProps: spec.SchemaProps{
							Description: "Weight of the framework in the runtime selector, used to prioritize modelFramework",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the model being referenced Identifies the specific model to be used for inference.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the model being referenced Defaults to ClusterBaseModel Specifies the Kubernetes resource kind of the referenced model.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiGroup": {
						SchemaProps: spec.SchemaProps{
							Description: "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced model.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"fineTunedWeights": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Optional FineTunedWeights references References to fine-tuned weights that should be applied to the base model.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelRevisionStates(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"activeModelState": {
						SchemaProps: spec.SchemaProps{
							Description: "High level state string: Pending, Standby, Loading, Loaded, FailedToLoad",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"targetModelState": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
				Required: []string{"activeModelState"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelSizeRangeSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ModelSizeRangeSpec defines the range of model sizes supported by this runtime",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"min": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum size of the model in bytes",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"max": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum size of the model in bytes",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"runtime": {
						SchemaProps: spec.SchemaProps{
							Description: "Specific ClusterServingRuntime/ServingRuntime name to use for deployment.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storageUri": {
						SchemaProps: spec.SchemaProps{
							Description: "This field points to the location of the model which is mounted onto the pod.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"runtimeVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Runtime version of the predictor docker image",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"protocolVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"command": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"args": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"containerPort",
									"protocol",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "containerPort",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerPort"),
									},
								},
							},
						},
					},
					"envFrom": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the container. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"resizePolicy": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources resize policy for the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerResizePolicy"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"mountPath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "mountPath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Pod volumes to mount into the container's filesystem. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"volumeDevices": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"devicePath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "devicePath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "volumeDevices is the list of block devices to be used by the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeDevice"),
									},
								},
							},
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"startupProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
							Ref:         ref("k8s.io/api/core/v1.Lifecycle"),
						},
					},
					"terminationMessagePath": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationMessagePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
							Ref:         ref("k8s.io/api/core/v1.SecurityContext"),
						},
					},
					"stdin": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"stdinOnce": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tty": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"baseModel": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
					"fineTunedWeights": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.ContainerResizePolicy", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.Lifecycle", "k8s.io/api/core/v1.Probe", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext", "k8s.io/api/core/v1.VolumeDevice", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"transitionStatus": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the available predictor endpoints reflect the current Spec or is in transition",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelRevisionStates": {
						SchemaProps: spec.SchemaProps{
							Description: "State information of the predictor's model.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRevisionStates"),
						},
					},
					"lastFailureInfo": {
						SchemaProps: spec.SchemaProps{
							Description: "Details of last failure, when load of target model is failed or blocked.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FailureInfo"),
						},
					},
					"modelCopies": {
						SchemaProps: spec.SchemaProps{
							Description: "Model copy information of the predictor's model.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelCopies"),
						},
					},
				},
				Required: []string{"transitionStatus"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.FailureInfo", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelCopies", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelRevisionStates"},
	}
}

func schema_pkg_apis_ome_v1beta1_ModelStatusSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ModelStatusSpec defines the observed state of Model weight",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "LifeCycle is an enum of Deprecated, Experiment, Public, Internal",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"state": {
						SchemaProps: spec.SchemaProps{
							Description: "Status of the model weight",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodesReady": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"nodesFailed": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"state"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_NetworkPermission(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NetworkPermission defines outbound network permissions.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"allowHost": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AllowHost is a list of glob patterns for hosts to allow connections to.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"allowHost"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_NetworkUsageInfo(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NetworkUsageInfo provides network usage information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"bytesIn": {
						SchemaProps: spec.SchemaProps{
							Description: "BytesIn is the total bytes received.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"bytesOut": {
						SchemaProps: spec.SchemaProps{
							Description: "BytesOut is the total bytes sent.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"connectionsPerSecond": {
						SchemaProps: spec.SchemaProps{
							Description: "ConnectionsPerSecond is the rate of new connections.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"bytesIn", "bytesOut", "connectionsPerSecond"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_OAuth2Credentials(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "OAuth2Credentials defines OAuth2 authentication credentials.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"clientID": {
						SchemaProps: spec.SchemaProps{
							Description: "ClientID for OAuth2 authentication.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"clientSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ClientSecret references the OAuth2 client secret.",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"),
						},
					},
					"tokenURL": {
						SchemaProps: spec.SchemaProps{
							Description: "TokenURL is the OAuth2 token endpoint.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"scopes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Scopes define the OAuth2 scopes to request.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"clientID", "clientSecret", "tokenURL"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.CredentialRef"},
	}
}

func schema_pkg_apis_ome_v1beta1_OIDCConfigSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "OIDCConfigSource defines the source of OIDC configuration. Only one of the fields may be set.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kubernetes": {
						SchemaProps: spec.SchemaProps{
							Description: "Kubernetes configures OIDC to validate Kubernetes service account tokens.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubernetesOIDCConfig"),
						},
					},
					"inline": {
						SchemaProps: spec.SchemaProps{
							Description: "Inline contains a direct OIDC provider configuration.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineOIDCConfig"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.InlineOIDCConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubernetesOIDCConfig"},
	}
}

func schema_pkg_apis_ome_v1beta1_ObjectReference(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ObjectReference contains enough information to let you inspect or modify the referred object.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the referenced object",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace of the referenced object",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_PIIDetectionConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PIIDetectionConfig defines PII detection and handling.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether PII detection is active.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"patterns": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Patterns define PII detection patterns.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIPattern"),
									},
								},
							},
						},
					},
					"action": {
						SchemaProps: spec.SchemaProps{
							Description: "Action defines the action to take when PII is detected.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PIIPattern"},
	}
}

func schema_pkg_apis_ome_v1beta1_PIIPattern(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PIIPattern defines a PII detection pattern.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type defines the PII type.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pattern": {
						SchemaProps: spec.SchemaProps{
							Description: "Pattern is a regex pattern for custom PII detection.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"description": {
						SchemaProps: spec.SchemaProps{
							Description: "Description provides a human-readable description.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"type"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_PermissionProfileSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PermissionProfileSource defines the source of a permission profile. Only one of the fields may be set.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"builtin": {
						SchemaProps: spec.SchemaProps{
							Description: "Builtin selects a pre-defined, named permission profile.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BuiltinPermissionProfile"),
						},
					},
					"configMap": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMap references a ConfigMap containing a permission profile specification.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"inline": {
						SchemaProps: spec.SchemaProps{
							Description: "Inline contains an embedded permission profile specification.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BuiltinPermissionProfile", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionProfileSpec", "k8s.io/api/core/v1.ConfigMapKeySelector"},
	}
}

func schema_pkg_apis_ome_v1beta1_PermissionProfileSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PermissionProfileSpec defines the permissions for an MCP server.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"allow": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Allow specifies the permissions granted to the server.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionRule"),
									},
								},
							},
						},
					},
				},
				Required: []string{"allow"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.PermissionRule"},
	}
}

func schema_pkg_apis_ome_v1beta1_PermissionRule(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PermissionRule defines a single permission grant.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kubeResources": {
						SchemaProps: spec.SchemaProps{
							Description: "KubeResources defines permissions for accessing Kubernetes resources.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubeResourcePermission"),
						},
					},
					"network": {
						SchemaProps: spec.SchemaProps{
							Description: "Network defines permissions for making outbound network calls.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkPermission"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KubeResourcePermission", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkPermission"},
	}
}

func schema_pkg_apis_ome_v1beta1_PodOverride(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Image specifies the container image to use for the benchmark job.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"envFrom": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type": "map",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Pod volumes to mount into the container's filesystem.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type":       "atomic",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_ome_v1beta1_PodSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PodSpec is a description of a pod.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_PredictorExtensionSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PredictorExtensionSpec defines configuration shared across all predictor frameworks",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"storageUri": {
						SchemaProps: spec.SchemaProps{
							Description: "This field points to the location of the model which is mounted onto the pod.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"runtimeVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Runtime version of the predictor docker image",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"protocolVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"command": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"args": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"containerPort",
									"protocol",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "containerPort",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerPort"),
									},
								},
							},
						},
					},
					"envFrom": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the container. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"resizePolicy": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources resize policy for the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerResizePolicy"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"mountPath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "mountPath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Pod volumes to mount into the container's filesystem. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"volumeDevices": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"devicePath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "devicePath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "volumeDevices is the list of block devices to be used by the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeDevice"),
									},
								},
							},
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"startupProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
							Ref:         ref("k8s.io/api/core/v1.Lifecycle"),
						},
					},
					"terminationMessagePath": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationMessagePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
							Ref:         ref("k8s.io/api/core/v1.SecurityContext"),
						},
					},
					"stdin": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"stdinOnce": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tty": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.ContainerResizePolicy", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.Lifecycle", "k8s.io/api/core/v1.Probe", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext", "k8s.io/api/core/v1.VolumeDevice", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_ome_v1beta1_PredictorSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PredictorSpec defines the configuration for a predictor, The following fields follow a \"1-of\" semantic. Users must specify exactly one spec.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"model": {
						SchemaProps: spec.SchemaProps{
							Description: "Model spec for any arbitrary framework.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSpec"),
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum number of replicas for autoscaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleMetric": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"canaryTrafficPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxUnavailable specifies how many component pods can be unavailable",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"deploymentStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
							Ref:         ref("k8s.io/api/apps/v1.DeploymentStrategy"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
					"workerSpec": {
						SchemaProps: spec.SchemaProps{
							Description: "WorkerSpec for the predictor, this is used for multi-node serving without Ray Cluster",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerSpec", "k8s.io/api/apps/v1.DeploymentStrategy", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_ome_v1beta1_PromptRegistryStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PromptRegistryStatus provides status of the prompt registry.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"totalPrompts": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalPrompts is the total number of registered prompts.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lastUpdated": {
						SchemaProps: spec.SchemaProps{
							Description: "LastUpdated is when the registry was last updated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_RateLimitConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RateLimitConfig defines rate limiting policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"global": {
						SchemaProps: spec.SchemaProps{
							Description: "Global rate limit applied to all requests.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy"),
						},
					},
					"perUser": {
						SchemaProps: spec.SchemaProps{
							Description: "PerUser defines rate limits per authenticated user.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy"),
						},
					},
					"perIP": {
						SchemaProps: spec.SchemaProps{
							Description: "PerIP defines rate limits per client IP address.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy"),
						},
					},
					"perServer": {
						SchemaProps: spec.SchemaProps{
							Description: "PerServer defines rate limits per upstream server.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RateLimitPolicy"},
	}
}

func schema_pkg_apis_ome_v1beta1_RateLimitPolicy(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RateLimitPolicy defines a rate limiting policy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requestsPerSecond": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerSecond is the number of requests allowed per second.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"requestsPerMinute": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerMinute is the number of requests allowed per minute.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"requestsPerHour": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerHour is the number of requests allowed per hour.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"burst": {
						SchemaProps: spec.SchemaProps{
							Description: "Burst is the burst capacity for rate limiting.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_RemoteMCPServer(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RemoteMCPServer defines a server that is accessed via an external URL.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the external URL of the remote MCP server.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"url"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_RequestFilteringConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RequestFilteringConfig defines request filtering policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"sizeLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "SizeLimit defines maximum request size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"contentTypeFilter": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ContentTypeFilter defines allowed content types.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"headerFilters": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HeaderFilters define header filtering rules.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HeaderFilter"),
									},
								},
							},
						},
					},
					"bodyFilters": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "BodyFilters define body content filtering rules.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BodyFilter"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BodyFilter", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HeaderFilter", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_ResourceRegistryStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceRegistryStatus provides status of the resource registry.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"totalResources": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalResources is the total number of registered resources.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"cacheHitRate": {
						SchemaProps: spec.SchemaProps{
							Description: "CacheHitRate is the resource cache hit rate as a percentage.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"lastUpdated": {
						SchemaProps: spec.SchemaProps{
							Description: "LastUpdated is when the registry was last updated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_ResourceUsageStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceUsageStatus provides current resource utilization information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"cpuUsage": {
						SchemaProps: spec.SchemaProps{
							Description: "CPU usage as a percentage of allocated resources.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"memoryUsage": {
						SchemaProps: spec.SchemaProps{
							Description: "Memory usage as a percentage of allocated resources.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storageUsage": {
						SchemaProps: spec.SchemaProps{
							Description: "Storage usage for context and cache storage.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageUsageInfo"),
						},
					},
					"networkUsage": {
						SchemaProps: spec.SchemaProps{
							Description: "Network usage statistics.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkUsageInfo"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.NetworkUsageInfo", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageUsageInfo"},
	}
}

func schema_pkg_apis_ome_v1beta1_ResponseFilteringConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResponseFilteringConfig defines response filtering policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"sizeLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "SizeLimit defines maximum response size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"headerFilters": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HeaderFilters define response header filtering rules.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HeaderFilter"),
									},
								},
							},
						},
					},
					"bodyFilters": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "BodyFilters define response body filtering rules.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BodyFilter"),
									},
								},
							},
						},
					},
					"removeInternalHeaders": {
						SchemaProps: spec.SchemaProps{
							Description: "RemoveInternalHeaders controls whether to remove internal headers.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.BodyFilter", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.HeaderFilter", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_RouterSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RouterSpec defines the configuration for the Router component, which handles request routing",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"minReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"maxReplicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Maximum number of replicas for autoscaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleTarget": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"scaleMetric": {
						SchemaProps: spec.SchemaProps{
							Description: "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"containerConcurrency": {
						SchemaProps: spec.SchemaProps{
							Description: "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"timeoutSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"canaryTrafficPercent": {
						SchemaProps: spec.SchemaProps{
							Description: "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"minAvailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"maxUnavailable": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxUnavailable specifies how many component pods can be unavailable",
							Ref:         ref("k8s.io/apimachinery/pkg/util/intstr.IntOrString"),
						},
					},
					"deploymentStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
							Ref:         ref("k8s.io/api/apps/v1.DeploymentStrategy"),
						},
					},
					"kedaConfig": {
						SchemaProps: spec.SchemaProps{
							Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig"),
						},
					},
					"runner": {
						SchemaProps: spec.SchemaProps{
							Description: "This is essentially a container spec that can override the default container",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec"),
						},
					},
					"config": {
						SchemaProps: spec.SchemaProps{
							Description: "Additional configuration parameters for the runner This can include framework-specific settings",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.KedaConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec", "k8s.io/api/apps/v1.DeploymentStrategy", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/util/intstr.IntOrString"},
	}
}

func schema_pkg_apis_ome_v1beta1_RunnerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RunnerSpec defines container configuration plus additional config settings The Runner is the primary container that executes the model serving or token generation logic.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"image": {
						SchemaProps: spec.SchemaProps{
							Description: "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"command": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"args": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"workingDir": {
						SchemaProps: spec.SchemaProps{
							Description: "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"containerPort",
									"protocol",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "containerPort",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerPort"),
									},
								},
							},
						},
					},
					"envFrom": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvFromSource"),
									},
								},
							},
						},
					},
					"env": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of environment variables to set in the container. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EnvVar"),
									},
								},
							},
						},
					},
					"resources": {
						SchemaProps: spec.SchemaProps{
							Description: "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/api/core/v1.ResourceRequirements"),
						},
					},
					"resizePolicy": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Resources resize policy for the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ContainerResizePolicy"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"volumeMounts": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"mountPath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "mountPath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Pod volumes to mount into the container's filesystem. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeMount"),
									},
								},
							},
						},
					},
					"volumeDevices": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"devicePath",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "devicePath",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "volumeDevices is the list of block devices to be used by the container.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.VolumeDevice"),
									},
								},
							},
						},
					},
					"livenessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"readinessProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"startupProbe": {
						SchemaProps: spec.SchemaProps{
							Description: "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
							Ref:         ref("k8s.io/api/core/v1.Probe"),
						},
					},
					"lifecycle": {
						SchemaProps: spec.SchemaProps{
							Description: "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
							Ref:         ref("k8s.io/api/core/v1.Lifecycle"),
						},
					},
					"terminationMessagePath": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationMessagePolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"imagePullPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
							Ref:         ref("k8s.io/api/core/v1.SecurityContext"),
						},
					},
					"stdin": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"stdinOnce": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tty": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ContainerPort", "k8s.io/api/core/v1.ContainerResizePolicy", "k8s.io/api/core/v1.EnvFromSource", "k8s.io/api/core/v1.EnvVar", "k8s.io/api/core/v1.Lifecycle", "k8s.io/api/core/v1.Probe", "k8s.io/api/core/v1.ResourceRequirements", "k8s.io/api/core/v1.SecurityContext", "k8s.io/api/core/v1.VolumeDevice", "k8s.io/api/core/v1.VolumeMount"},
	}
}

func schema_pkg_apis_ome_v1beta1_SamplingPolicyConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SamplingPolicyConfig defines server-to-client sampling request policy.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether servers can request sampling from clients.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"clientModel": {
						SchemaProps: spec.SchemaProps{
							Description: "ClientModel defines which AI model to use for sampling requests.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"maxTokens": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxTokens defines the maximum tokens for sampling requests.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"temperature": {
						SchemaProps: spec.SchemaProps{
							Description: "Temperature controls the randomness of sampling responses.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"timeout": {
						SchemaProps: spec.SchemaProps{
							Description: "Timeout defines the maximum time to wait for sampling responses.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"rateLimit": {
						SchemaProps: spec.SchemaProps{
							Description: "RateLimit defines rate limiting for sampling requests.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingRateLimit"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SamplingRateLimit", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_SamplingRateLimit(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SamplingRateLimit defines rate limiting for sampling requests.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"requestsPerMinute": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerMinute is the maximum sampling requests per minute.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"requestsPerHour": {
						SchemaProps: spec.SchemaProps{
							Description: "RequestsPerHour is the maximum sampling requests per hour.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ServerStatusSummary(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServerStatusSummary provides an aggregated summary of server statuses.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"total": {
						SchemaProps: spec.SchemaProps{
							Description: "Total number of configured servers.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"connected": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of servers that are connected and healthy.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"disconnected": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of servers that are disconnected.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"unhealthy": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of servers that are unhealthy.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"circuitOpen": {
						SchemaProps: spec.SchemaProps{
							Description: "Number of servers with open circuit breakers.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"total", "connected", "disconnected", "unhealthy", "circuitOpen"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ServiceMetadata(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServiceMetadata contains metadata fields for recording the backend model server's configuration and version details. This information helps track experiment context, enabling users to filter and query experiments based on server properties.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"engine": {
						SchemaProps: spec.SchemaProps{
							Description: "Engine specifies the backend model server engine. Supported values: \"vLLM\", \"SGLang\", \"TGI\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version specifies the version of the model server (e.g., \"0.5.3\").",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"gpuType": {
						SchemaProps: spec.SchemaProps{
							Description: "GpuType specifies the type of GPU used by the model server. Supported values: \"H100\", \"A100\", \"MI300\", \"A10\".",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"gpuCount": {
						SchemaProps: spec.SchemaProps{
							Description: "GpuCount indicates the number of GPU cards available on the model server.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
				Required: []string{"engine", "version", "gpuType", "gpuCount"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntime(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServingRuntime is the Schema for the servingruntimes API",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeStatus"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntimeList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServingRuntimeList contains a list of ServingRuntime",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntime"),
									},
								},
							},
						},
					},
				},
				Required: []string{"items"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntime", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntimePodSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume"},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntimeRef(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the runtime being referenced Identifies the specific runtime environment to be used for model execution.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind of the runtime being referenced Defaults to ClusterServingRuntime Specifies the Kubernetes resource kind of the referenced runtime. ClusterServingRuntime is a cluster-wide runtime, while ServingRuntime is namespace-scoped.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiGroup": {
						SchemaProps: spec.SchemaProps{
							Description: "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced runtime.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntimeSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServingRuntimeSpec defines the desired state of ServingRuntime. This spec is currently provisional and are subject to change as details regarding single-model serving and multi-model serving are hammered out.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"supportedModelFormats": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Model formats and version supported by this runtime",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SupportedModelFormat"),
									},
								},
							},
						},
					},
					"modelSizeRange": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelSizeRange is the range of model sizes supported by this runtime",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSizeRangeSpec"),
						},
					},
					"disabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Set to true to disable use of this runtime",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"routerConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Router configuration for this runtime",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RouterSpec"),
						},
					},
					"engineConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Engine configuration for this runtime",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EngineSpec"),
						},
					},
					"decoderConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Decoder configuration for this runtime",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DecoderSpec"),
						},
					},
					"protocolVersions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Supported protocol versions (i.e. openAI or cohere or openInference-v1 or openInference-v2)",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"workers": {
						SchemaProps: spec.SchemaProps{
							Description: "WorkerPodSpec for the serving runtime, this is used for multi-node serving without Ray Cluster",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerPodSpec"),
						},
					},
					"acceleratorRequirements": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorRequirements specifies the accelerator requirements for this runtime",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorRequirements"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorRequirements", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.DecoderSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.EngineSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelSizeRangeSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RouterSpec", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.SupportedModelFormat", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.WorkerPodSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume"},
	}
}

func schema_pkg_apis_ome_v1beta1_ServingRuntimeStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ServingRuntimeStatus defines the observed state of ServingRuntime",
				Type:        []string{"object"},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_SessionIsolationConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SessionIsolationConfig defines session isolation and context boundary policies.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"mode": {
						SchemaProps: spec.SchemaProps{
							Description: "Mode defines the isolation level for MCP sessions.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"crossSessionSharing": {
						SchemaProps: spec.SchemaProps{
							Description: "CrossSessionSharing controls whether data can be shared between sessions.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"contextRetention": {
						SchemaProps: spec.SchemaProps{
							Description: "ContextRetention defines how long session context is retained.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
					"auditLevel": {
						SchemaProps: spec.SchemaProps{
							Description: "AuditLevel defines the audit logging level for session boundaries.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enforceResourceBoundaries": {
						SchemaProps: spec.SchemaProps{
							Description: "EnforceResourceBoundaries controls whether resource access is strictly bounded per session.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"allowedCrossSessionData": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "set",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "AllowedCrossSessionData defines what data types can be shared across sessions when enabled.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_StorageMetrics(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageMetrics provides storage metrics.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"used": {
						SchemaProps: spec.SchemaProps{
							Description: "Used storage in bytes.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"available": {
						SchemaProps: spec.SchemaProps{
							Description: "Available storage in bytes.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"usagePercent": {
						SchemaProps: spec.SchemaProps{
							Description: "Usage percentage.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"used", "available", "usagePercent"},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_StorageSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is the absolute path where the model will be downloaded and stored on the node.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"schemaPath": {
						SchemaProps: spec.SchemaProps{
							Description: "SchemaPath is the path to the model schema or configuration file within the storage system. This can be used to validate the model or customize how it's loaded.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"parameters": {
						SchemaProps: spec.SchemaProps{
							Description: "Parameters contain key-value pairs to override default storage credentials or configuration. These values are typically used to configure access to object storage or mount options.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "StorageKey is the name of the key in a Kubernetes Secret used to authenticate access to the model storage. This key will be used to fetch credentials during model download or access.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"storageUri": {
						SchemaProps: spec.SchemaProps{
							Description: "StorageUri specifies the source URI of the model in a supported storage backend. Supported formats: - OCI Object Storage:   oci://n/{namespace}/b/{bucket}/o/{object_path} - Persistent Volume:    pvc://{pvc-name}/{sub-path} - Vendor-specific:      vendor://{vendor-name}/{resource-type}/{resource-path} This field is required.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector defines a set of key-value label pairs that must be present on a node for the model to be scheduled and downloaded onto that node.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"nodeAffinity": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeAffinity describes the node affinity rules that further constrain which nodes are eligible to download and store this model, based on advanced scheduling policies.",
							Ref:         ref("k8s.io/api/core/v1.NodeAffinity"),
						},
					},
				},
				Required: []string{"storageUri"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.NodeAffinity"},
	}
}

func schema_pkg_apis_ome_v1beta1_StorageUsageInfo(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageUsageInfo provides storage usage information.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"contextStorage": {
						SchemaProps: spec.SchemaProps{
							Description: "ContextStorage usage information.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageMetrics"),
						},
					},
					"cacheStorage": {
						SchemaProps: spec.SchemaProps{
							Description: "CacheStorage usage information.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageMetrics"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.StorageMetrics"},
	}
}

func schema_pkg_apis_ome_v1beta1_SupportedModelFormat(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the model",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelFormat": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelFormat of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"SafeTensors\"",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFormat"),
						},
					},
					"modelType": {
						SchemaProps: spec.SchemaProps{
							Description: "DEPRECATED: This field is deprecated and will be removed in future releases.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"modelFramework": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelFramework of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"Transformers\"",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFrameworkSpec"),
						},
					},
					"modelArchitecture": {
						SchemaProps: spec.SchemaProps{
							Description: "ModelArchitecture of the model, e.g., \"LlamaForCausalLM\", \"GemmaForCausalLM\", \"MixtralForCausalLM\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"quantization": {
						SchemaProps: spec.SchemaProps{
							Description: "Quantization of the model, e.g., \"fp8\", \"fbgemm_fp8\", \"int4\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"autoSelect": {
						SchemaProps: spec.SchemaProps{
							Description: "Set to true to allow the ServingRuntime to be used for automatic model placement if this model format is specified with no explicit runtime.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "Priority of this serving runtime for auto selection. This is used to select the serving runtime if more than one serving runtime supports the same model format. The value should be greater than zero.  The higher the value, the higher the priority. Priority is not considered if AutoSelect is either false or not specified. Priority can be overridden by specifying the runtime in the InferenceService.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"acceleratorConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "AcceleratorConfig provides accelerator-specific overrides for this model format",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorModelConfig"),
									},
								},
							},
						},
					},
				},
				Required: []string{"modelFormat", "modelFramework"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.AcceleratorModelConfig", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFormat", "github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ModelFrameworkSpec"},
	}
}

func schema_pkg_apis_ome_v1beta1_SupportedRuntime(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SupportedRuntime is the schema for supported runtime result of automatic selection",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"Name": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"Spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec"),
						},
					},
				},
				Required: []string{"Name", "Spec"},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.ServingRuntimeSpec"},
	}
}

func schema_pkg_apis_ome_v1beta1_TensorParallelismConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TensorParallelismConfig specifies tensor parallelism settings",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"tensorParallelSize": {
						SchemaProps: spec.SchemaProps{
							Description: "tensorParallelSize specifies the size of the tensor parallelism",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"pipelineParallelSize": {
						SchemaProps: spec.SchemaProps{
							Description: "pipelineParallelSize specifies the size of the pipeline parallelism",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dataParallelSize": {
						SchemaProps: spec.SchemaProps{
							Description: "dataParallelSize specifies the size of the data parallelism",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_ToolRegistryStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ToolRegistryStatus provides status of the tool registry.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"totalTools": {
						SchemaProps: spec.SchemaProps{
							Description: "TotalTools is the total number of registered tools.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"mcpTools": {
						SchemaProps: spec.SchemaProps{
							Description: "MCPTools is the number of native MCP tools.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"restTools": {
						SchemaProps: spec.SchemaProps{
							Description: "RestTools is the number of virtualized REST API tools.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"lastUpdated": {
						SchemaProps: spec.SchemaProps{
							Description: "LastUpdated is when the registry was last updated.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_ome_v1beta1_TracingConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "TracingConfig defines distributed tracing configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled controls whether distributed tracing is active.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"provider": {
						SchemaProps: spec.SchemaProps{
							Description: "Provider defines the tracing backend provider.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint defines the tracing collector endpoint.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"samplingRate": {
						SchemaProps: spec.SchemaProps{
							Description: "SamplingRate defines the sampling rate for traces (0.0-1.0).",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"headers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Headers define additional headers to send with traces.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_ome_v1beta1_WebSocketTransportConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WebSocketTransportConfig defines WebSocket transport configuration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port defines the WebSocket port.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"readBufferSize": {
						SchemaProps: spec.SchemaProps{
							Description: "ReadBufferSize defines the read buffer size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"writeBufferSize": {
						SchemaProps: spec.SchemaProps{
							Description: "WriteBufferSize defines the write buffer size.",
							Ref:         ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
						},
					},
					"pingInterval": {
						SchemaProps: spec.SchemaProps{
							Description: "PingInterval defines the ping interval for keep-alive.",
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Duration"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/apimachinery/pkg/api/resource.Quantity", "k8s.io/apimachinery/pkg/apis/meta/v1.Duration"},
	}
}

func schema_pkg_apis_ome_v1beta1_WorkerPodSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "Size of the worker, this is the number of pods in the worker.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"annotations": {
						SchemaProps: spec.SchemaProps{
							Description: "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume"},
	}
}

func schema_pkg_apis_ome_v1beta1_WorkerSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkerSpec defines the configuration for worker nodes in a multi-node component Worker nodes perform the distributed processing tasks assigned by the leader node, enabling horizontal scaling for compute-intensive workloads.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"initContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"containers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Container"),
									},
								},
							},
						},
					},
					"ephemeralContainers": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.EphemeralContainer"),
									},
								},
							},
						},
					},
					"restartPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"terminationGracePeriodSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"activeDeadlineSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"dnsPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"nodeSelector": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-map-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serviceAccount": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"automountServiceAccountToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"nodeName": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"hostNetwork": {
						SchemaProps: spec.SchemaProps{
							Description: "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostPID": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's pid namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"hostIPC": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's ipc namespace. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"shareProcessNamespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"hostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subdomain": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the fully qualified Pod hostname will be \"<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>\". If not specified, the pod will not have a domainname at all.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"schedulerName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tolerations": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"hostAliases": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"ip",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "ip",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.HostAlias"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"dnsConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
							Ref:         ref("k8s.io/api/core/v1.PodDNSConfig"),
						},
					},
					"readinessGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-type": "atomic",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodReadinessGate"),
									},
								},
							},
						},
					},
					"runtimeClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"enableServiceLinks": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"preemptionPolicy": {
						SchemaProps: spec.SchemaProps{
							Description: "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"overhead": {
						SchemaProps: spec.SchemaProps{
							Description: "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Ref: ref("k8s.io/apimachinery/pkg/api/resource.Quantity"),
									},
								},
							},
						},
					},
					"topologySpreadConstraints": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"topologyKey",
									"whenUnsatisfiable",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "topologyKey",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.TopologySpreadConstraint"),
									},
								},
							},
						},
					},
					"setHostnameAsFQDN": {
						SchemaProps: spec.SchemaProps{
							Description: "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"os": {
						SchemaProps: spec.SchemaProps{
							Description: "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
							Ref:         ref("k8s.io/api/core/v1.PodOS"),
						},
					},
					"hostUsers": {
						SchemaProps: spec.SchemaProps{
							Description: "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"schedulingGates": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodSchedulingGate"),
									},
								},
							},
						},
					},
					"resourceClaims": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"name",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge,retainKeys",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.PodResourceClaim"),
									},
								},
							},
						},
					},
					"size": {
						SchemaProps: spec.SchemaProps{
							Description: "Size of the worker, this is the number of pods in the worker. Controls how many worker pod instances will be deployed for horizontal scaling.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"runner": {
						SchemaProps: spec.SchemaProps{
							Description: "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the worker node's processing logic.",
							Ref:         ref("github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/sgl-project/ome/pkg/apis/ome/v1beta1.RunnerSpec", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.EphemeralContainer", "k8s.io/api/core/v1.HostAlias", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodDNSConfig", "k8s.io/api/core/v1.PodOS", "k8s.io/api/core/v1.PodReadinessGate", "k8s.io/api/core/v1.PodResourceClaim", "k8s.io/api/core/v1.PodSchedulingGate", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.TopologySpreadConstraint", "k8s.io/api/core/v1.Volume", "k8s.io/apimachinery/pkg/api/resource.Quantity"},
	}
}

func schema_pkg_apis_ome_v1beta1_WorkflowStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WorkflowStatus provides status of workflow orchestration.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"activeWorkflows": {
						SchemaProps: spec.SchemaProps{
							Description: "ActiveWorkflows is the number of currently active workflows.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"completedWorkflows": {
						SchemaProps: spec.SchemaProps{
							Description: "CompletedWorkflows is the total number of completed workflows.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"failedWorkflows": {
						SchemaProps: spec.SchemaProps{
							Description: "FailedWorkflows is the total number of failed workflows.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"averageExecutionTime": {
						SchemaProps: spec.SchemaProps{
							Description: "AverageExecutionTime is the average workflow execution time in seconds.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}
