{
  "swagger": "2.0",
  "info": {
    "description": "Python SDK for OME",
    "title": "OME",
    "version": "v0.1"
  },
  "paths": {},
  "definitions": {
    "v1beta1.AcceleratorCapabilities": {
      "type": "object",
      "properties": {
        "clockSpeedMHz": {
          "description": "Clock speeds",
          "type": "integer",
          "format": "int32"
        },
        "computeCapability": {
          "description": "Compute capability (NVIDIA) or equivalent",
          "type": "string"
        },
        "features": {
          "description": "Features supported by this accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "levelZeroVersion": {
          "description": "Level Zero version (for Intel accelerators)",
          "type": "string"
        },
        "memoryBandwidthGBps": {
          "description": "Memory bandwidth",
          "$ref": "#/definitions/resource.Quantity"
        },
        "memoryGB": {
          "description": "Memory capacity in GB",
          "$ref": "#/definitions/resource.Quantity"
        },
        "performance": {
          "description": "Performance metrics",
          "$ref": "#/definitions/v1beta1.AcceleratorPerformance"
        }
      }
    },
    "v1beta1.AcceleratorClass": {
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorClassSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorClassStatus"
        }
      }
    },
    "v1beta1.AcceleratorClassList": {
      "description": "AcceleratorClassList contains a list of AcceleratorClass",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.AcceleratorClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.AcceleratorClassSpec": {
      "type": "object",
      "required": [
        "discovery",
        "capabilities"
      ],
      "properties": {
        "capabilities": {
          "description": "Capabilities of this accelerator class",
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorCapabilities"
        },
        "cost": {
          "description": "Cost information for optimization decisions",
          "$ref": "#/definitions/v1beta1.AcceleratorCost"
        },
        "discovery": {
          "description": "Discovery patterns to identify nodes with this accelerator",
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorDiscovery"
        },
        "family": {
          "description": "Family of the accelerator (ampere, hopper, cdna2, etc.)",
          "type": "string"
        },
        "integration": {
          "description": "Integration with external systems",
          "$ref": "#/definitions/v1beta1.AcceleratorIntegration"
        },
        "model": {
          "description": "Model name (a100, h100, mi250x, etc.)",
          "type": "string"
        },
        "resources": {
          "description": "Resources exposed by this accelerator",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.AcceleratorResource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "vendor": {
          "description": "Vendor of the accelerator (nvidia, amd, intel, etc.)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorClassStatus": {
      "type": "object",
      "properties": {
        "availableAccelerators": {
          "description": "Available accelerators (not allocated)",
          "type": "integer",
          "format": "int32"
        },
        "availableNodes": {
          "description": "AvailableNodes is the number of nodes that have this accelerator available",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Conditions represent the latest available observations",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Condition"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "lastUpdated": {
          "description": "Last update time",
          "$ref": "#/definitions/v1.Time"
        },
        "nodes": {
          "description": "Nodes that have this accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "totalAccelerators": {
          "description": "Total number of accelerators in the cluster",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.AcceleratorConstraints": {
      "description": "AcceleratorConstraints defines requirements for accelerator selection",
      "type": "object",
      "properties": {
        "architectureFamilies": {
          "description": "ArchitectureFamilies limits selection to specific families Examples: [\"nvidia-hopper\", \"nvidia-ampere\"]",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "excludedClasses": {
          "description": "ExcludedClasses lists AcceleratorClasses to avoid",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "maxMemory": {
          "description": "MaxMemory in GB (useful for cost control)",
          "type": "integer",
          "format": "int64"
        },
        "minComputeCapability": {
          "description": "MinComputeCapability in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "minMemory": {
          "description": "MinMemory in GB",
          "type": "integer",
          "format": "int64"
        },
        "requiredFeatures": {
          "description": "RequiredFeatures that must be present",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.AcceleratorCost": {
      "type": "object",
      "properties": {
        "perHour": {
          "description": "Cost per hour in dollars",
          "$ref": "#/definitions/resource.Quantity"
        },
        "perMillionTokens": {
          "description": "Cost per million tokens (for usage-based pricing)",
          "$ref": "#/definitions/resource.Quantity"
        },
        "spotPerHour": {
          "description": "Spot instance pricing if available",
          "$ref": "#/definitions/resource.Quantity"
        },
        "tier": {
          "description": "Cost tier for simplified selection (low, medium, high)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorDiscovery": {
      "type": "object",
      "properties": {
        "deviceIDs": {
          "description": "DeviceIDs list of PCI device IDs",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodeSelector": {
          "description": "NodeSelector to identify nodes with this accelerator",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelectorTerms": {
          "description": "NodeSelectorTerms for more complex node selection",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.NodeSelectorTerm"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "pciVendorID": {
          "description": "PCIVendorID for device discovery (e.g., \"10de\" for NVIDIA)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorIntegration": {
      "type": "object",
      "properties": {
        "kueueResourceFlavor": {
          "description": "KueueResourceFlavor name to sync with",
          "type": "string"
        },
        "volcanoGPUType": {
          "description": "VolcanoGPUType for Volcano integration",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorLatency": {
      "type": "object",
      "properties": {
        "averageMillis": {
          "description": "Average latency in milliseconds",
          "type": "integer",
          "format": "int64"
        },
        "maximumMillis": {
          "description": "Maximum latency in milliseconds",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.AcceleratorModelConfig": {
      "description": "AcceleratorModelConfig provides accelerator-specific overrides for this model format",
      "type": "object",
      "properties": {
        "environmentOverride": {
          "description": "EnvironmentOverride provides accelerator-specific environment variables",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "minMemoryPerBillionParams": {
          "description": "MinMemoryPerBillionParams specifies memory required per billion parameters Used to calculate if a model fits on the accelerator",
          "type": "integer",
          "format": "int64"
        },
        "runtimeArgsOverride": {
          "description": "RuntimeArgsOverride provides accelerator-specific runtime arguments",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tensorParallelismOverride": {
          "description": "TensorParallelismOverride overrides the default tensor parallelism settings",
          "$ref": "#/definitions/v1beta1.TensorParallelismConfig"
        }
      }
    },
    "v1beta1.AcceleratorPerformance": {
      "type": "object",
      "properties": {
        "fp16Tflops": {
          "description": "FP16 performance in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "fp32Tflops": {
          "description": "FP32 performance in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "int4Tops": {
          "description": "INT4 performance in TOPS",
          "type": "integer",
          "format": "int64"
        },
        "int8Tops": {
          "description": "INT8 performance in TOPS",
          "type": "integer",
          "format": "int64"
        },
        "latency": {
          "description": "Latency metrics",
          "$ref": "#/definitions/v1beta1.AcceleratorLatency"
        }
      }
    },
    "v1beta1.AcceleratorRequirements": {
      "description": "AcceleratorRequirements specifies the accelerator requirements for this runtime",
      "type": "object",
      "properties": {
        "acceleratorClasses": {
          "description": "AcceleratorClasses lists the names of AcceleratorClasses this runtime supports If empty, the runtime supports any accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "minComputeCapability": {
          "description": "MinComputeCapability specifies minimum compute capability in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "minMemory": {
          "description": "MinMemory specifies minimum GPU memory required in GB",
          "type": "integer",
          "format": "int64"
        },
        "preferredPrecisions": {
          "description": "PreferredPrecisions lists numeric precisions in order of preference Examples: [\"fp8\", \"fp16\", \"fp32\"]",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "requiredFeatures": {
          "description": "RequiredFeatures lists hardware features that must be present Examples: [\"tensor-cores\", \"fp8\", \"nvlink\"]",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.AcceleratorResource": {
      "type": "object",
      "properties": {
        "divisible": {
          "description": "Divisible indicates if the resource can be subdivided",
          "type": "boolean"
        },
        "name": {
          "description": "Name of the resource (e.g., nvidia.com/gpu)",
          "type": "string",
          "default": ""
        },
        "quantity": {
          "description": "Quantity per accelerator",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.AcceleratorSelection": {
      "description": "AcceleratorSelection shows what accelerator was selected and why",
      "type": "object",
      "required": [
        "acceleratorClass"
      ],
      "properties": {
        "acceleratorClass": {
          "description": "AcceleratorClass that was selected",
          "type": "string",
          "default": ""
        },
        "nodeSelector": {
          "description": "NodeSelector that was applied to pods",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "reason": {
          "description": "Reason explains why this accelerator was selected",
          "type": "string"
        },
        "resourceRequests": {
          "description": "ResourceRequests that were applied to pods",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        }
      }
    },
    "v1beta1.AcceleratorSelector": {
      "description": "AcceleratorSelector defines how to select accelerators for the InferenceService",
      "type": "object",
      "properties": {
        "acceleratorClass": {
          "description": "AcceleratorClass explicitly selects a specific AcceleratorClass Takes precedence over other selectors",
          "type": "string"
        },
        "constraints": {
          "description": "Constraints defines requirements that accelerators must meet",
          "$ref": "#/definitions/v1beta1.AcceleratorConstraints"
        },
        "policy": {
          "description": "Policy defines the selection policy when multiple accelerators match",
          "type": "string"
        }
      }
    },
    "v1beta1.AuditConfig": {
      "description": "AuditConfig defines audit logging configuration.",
      "type": "object",
      "properties": {
        "destination": {
          "description": "Destination defines where audit logs are sent.",
          "$ref": "#/definitions/v1beta1.AuditDestinationConfig"
        },
        "enabled": {
          "description": "Enabled controls whether audit logging is active.",
          "type": "boolean"
        },
        "format": {
          "description": "Format defines the audit log format.",
          "type": "string"
        },
        "includeMetadata": {
          "description": "IncludeMetadata controls whether to include request metadata in audit logs.",
          "type": "boolean"
        },
        "level": {
          "description": "Level defines the audit logging level.",
          "type": "string"
        }
      }
    },
    "v1beta1.AuditDestinationConfig": {
      "description": "AuditDestinationConfig defines audit log destinations.",
      "type": "object",
      "properties": {
        "file": {
          "description": "File defines file-based audit logging.",
          "$ref": "#/definitions/v1beta1.AuditFileConfig"
        },
        "http": {
          "description": "HTTP defines HTTP-based audit logging.",
          "$ref": "#/definitions/v1beta1.AuditHTTPConfig"
        },
        "syslog": {
          "description": "Syslog defines syslog-based audit logging.",
          "$ref": "#/definitions/v1beta1.AuditSyslogConfig"
        },
        "type": {
          "description": "Type defines the destination type.",
          "type": "string"
        }
      }
    },
    "v1beta1.AuditFileConfig": {
      "description": "AuditFileConfig defines file-based audit logging.",
      "type": "object",
      "properties": {
        "maxBackups": {
          "description": "MaxBackups defines the maximum number of backup files to keep.",
          "type": "integer",
          "format": "int32"
        },
        "maxSize": {
          "description": "MaxSize defines the maximum log file size before rotation.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "path": {
          "description": "Path defines the audit log file path.",
          "type": "string"
        }
      }
    },
    "v1beta1.AuditHTTPConfig": {
      "description": "AuditHTTPConfig defines HTTP-based audit logging.",
      "type": "object",
      "required": [
        "endpoint"
      ],
      "properties": {
        "endpoint": {
          "description": "Endpoint defines the HTTP endpoint for audit logs.",
          "type": "string",
          "default": ""
        },
        "headers": {
          "description": "Headers define additional HTTP headers.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "method": {
          "description": "Method defines the HTTP method to use.",
          "type": "string"
        },
        "timeout": {
          "description": "Timeout defines the HTTP request timeout.",
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.AuditSyslogConfig": {
      "description": "AuditSyslogConfig defines syslog-based audit logging.",
      "type": "object",
      "required": [
        "server"
      ],
      "properties": {
        "facility": {
          "description": "Facility defines the syslog facility.",
          "type": "integer",
          "format": "int32"
        },
        "protocol": {
          "description": "Protocol defines the syslog protocol.",
          "type": "string"
        },
        "server": {
          "description": "Server defines the syslog server address.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.AuthConfig": {
      "description": "AuthConfig provides unified authentication configuration for all components.",
      "type": "object",
      "required": [
        "method"
      ],
      "properties": {
        "basic": {
          "description": "Basic provides basic authentication credentials.",
          "$ref": "#/definitions/v1beta1.BasicCredentials"
        },
        "clientCert": {
          "description": "ClientCert provides client certificate authentication.",
          "$ref": "#/definitions/v1beta1.ClientCertCredentials"
        },
        "jwt": {
          "description": "JWT provides JWT authentication configuration.",
          "$ref": "#/definitions/v1beta1.JWTCredentials"
        },
        "method": {
          "description": "Method defines the authentication method to use.",
          "type": "string",
          "default": ""
        },
        "oAuth2": {
          "description": "OAuth2 provides OAuth2 authentication configuration.",
          "$ref": "#/definitions/v1beta1.OAuth2Credentials"
        },
        "timeout": {
          "description": "Timeout defines the authentication request timeout.",
          "$ref": "#/definitions/v1.Duration"
        },
        "token": {
          "description": "Token provides the authentication token (Bearer, API Key).",
          "$ref": "#/definitions/v1beta1.CredentialRef"
        }
      }
    },
    "v1beta1.AuthzConfigSource": {
      "description": "AuthzConfigSource defines the source of an authorization policy. Only one of the fields may be set.",
      "type": "object",
      "properties": {
        "configMap": {
          "description": "ConfigMap references a ConfigMap containing the authorization policy.",
          "$ref": "#/definitions/v1.ConfigMapKeySelector"
        },
        "inline": {
          "description": "Inline contains an embedded authorization policy.",
          "$ref": "#/definitions/v1beta1.InlineAuthzConfig"
        }
      }
    },
    "v1beta1.BaseModel": {
      "description": "BaseModel is the Schema for the basemodels API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BaseModelSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.BaseModelList": {
      "description": "BaseModelList contains a list of BaseModel",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BaseModel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.BaseModelSpec": {
      "description": "BaseModelSpec defines the desired state of BaseModel",
      "type": "object",
      "required": [
        "storage"
      ],
      "properties": {
        "additionalMetadata": {
          "description": "Additional metadata for the model",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "maxTokens": {
          "description": "MaxTokens is the maximum number of tokens that can be processed by the model",
          "type": "integer",
          "format": "int32"
        },
        "modelArchitecture": {
          "description": "ModelArchitecture specifies the concrete model implementation or head, such as \"LlamaForCausalLM\", \"GemmaForCausalLM\", or \"MixtralForCausalLM\". This is often derived from the \"architectures\" field in Hugging Face config.json.",
          "type": "string"
        },
        "modelCapabilities": {
          "description": "ModelCapabilities of the model, e.g., \"TEXT_GENERATION\", \"TEXT_SUMMARIZATION\", \"TEXT_EMBEDDINGS\"",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "modelConfiguration": {
          "description": "Configuration of the model, stored as generic JSON for flexibility.",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "modelFormat": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelFormat"
        },
        "modelFramework": {
          "description": "ModelFramework specifies the underlying framework used by the model, such as \"ONNX\", \"TensorFlow\", \"PyTorch\", \"Transformer\", or \"TensorRTLLM\". This value helps determine the appropriate runtime for model serving.",
          "$ref": "#/definitions/v1beta1.ModelFrameworkSpec"
        },
        "modelParameterSize": {
          "description": "ModelParameterSize indicates the total number of parameters in the model, expressed in human-readable form such as \"7B\", \"13B\", or \"175B\". This can be used for scheduling or runtime selection.",
          "type": "string"
        },
        "modelType": {
          "description": "ModelType defines the architecture family of the model (e.g., \"bert\", \"gpt2\", \"llama\"). This value typically corresponds to the \"model_type\" field in a Hugging Face model's config.json. It is used to identify the transformer architecture and inform runtime selection and tokenizer behavior.",
          "type": "string"
        },
        "quantization": {
          "description": "Quantization defines the quantization scheme applied to the model weights, such as \"fp8\", \"fbgemm_fp8\", or \"int4\". This influences runtime compatibility and performance.",
          "type": "string"
        },
        "servingMode": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "storage": {
          "description": "Storage configuration for the model",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.BasicCredentials": {
      "description": "BasicCredentials defines basic authentication credentials.",
      "type": "object",
      "required": [
        "username",
        "password"
      ],
      "properties": {
        "password": {
          "description": "Password references the password secret.",
          "default": {},
          "$ref": "#/definitions/v1beta1.CredentialRef"
        },
        "username": {
          "description": "Username for basic authentication.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.BenchmarkJob": {
      "description": "BenchmarkJob is the schema for the BenchmarkJobs API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BenchmarkJobSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BenchmarkJobStatus"
        }
      }
    },
    "v1beta1.BenchmarkJobList": {
      "description": "BenchmarkJobList contains a list of BenchmarkJob",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BenchmarkJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.BenchmarkJobSpec": {
      "description": "BenchmarkJobSpec defines the specification for a benchmark job. All fields within this specification collectively represent the desired state and configuration of a BenchmarkJob.",
      "type": "object",
      "required": [
        "endpoint",
        "task",
        "maxTimePerIteration",
        "maxRequestsPerIteration",
        "outputLocation"
      ],
      "properties": {
        "additionalRequestParams": {
          "description": "AdditionalRequestParams contains additional request parameters as a map.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "dataset": {
          "description": "Dataset is the dataset used for benchmarking. It is optional and only required for tasks other than \"text-to-\u003coutput-modality\u003e\".",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "endpoint": {
          "description": "Endpoint is the reference to the inference service to benchmark.",
          "default": {},
          "$ref": "#/definitions/v1beta1.EndpointSpec"
        },
        "huggingFaceSecretReference": {
          "description": "HuggingFaceSecretReference is a reference to a Kubernetes Secret containing the Hugging Face API key. The referenced Secret must reside in the same namespace as the BenchmarkJob. This field replaces the raw HuggingFaceAPIKey field for improved security.",
          "$ref": "#/definitions/v1beta1.HuggingFaceSecretReference"
        },
        "maxRequestsPerIteration": {
          "description": "MaxRequestsPerIteration specifies the maximum number of requests for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
          "type": "integer",
          "format": "int32"
        },
        "maxTimePerIteration": {
          "description": "MaxTimePerIteration specifies the maximum time (in minutes) for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
          "type": "integer",
          "format": "int32"
        },
        "numConcurrency": {
          "description": "NumConcurrency defines a list of concurrency levels to test during the benchmark. If not provided, defaults will be assigned via genai-bench.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32",
            "default": 0
          },
          "x-kubernetes-list-type": "set"
        },
        "outputLocation": {
          "description": "OutputLocation specifies where the benchmark results will be stored (e.g., object storage).",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "podOverride": {
          "description": "Pod defines the pod configuration for the benchmark job. This is optional, if not provided, default values will be used.",
          "$ref": "#/definitions/v1beta1.PodOverride"
        },
        "resultFolderName": {
          "description": "ResultFolderName specifies the name of the folder that stores the benchmark result. A default name will be assigned if not specified.",
          "type": "string"
        },
        "serviceMetadata": {
          "description": "ServiceMetadata records metadata about the backend model server or service being benchmarked. This includes details such as server engine, version, and GPU configuration for filtering experiments.",
          "$ref": "#/definitions/v1beta1.ServiceMetadata"
        },
        "task": {
          "description": "Task specifies the task to benchmark, pattern: \u003cinput-modality\u003e-to-\u003coutput-modality\u003e (e.g., \"text-to-text\", \"image-to-text\").",
          "type": "string",
          "default": ""
        },
        "trafficScenarios": {
          "description": "TrafficScenarios contains a list of traffic scenarios to simulate during the benchmark. If not provided, defaults will be assigned via genai-bench.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.BenchmarkJobStatus": {
      "description": "BenchmarkJobStatus reflects the state and results of the benchmark job. It will be set and updated by the controller.",
      "type": "object",
      "required": [
        "state"
      ],
      "properties": {
        "completionTime": {
          "description": "CompletionTime is the timestamp for when the benchmark job completed, either successfully or unsuccessfully.",
          "$ref": "#/definitions/v1.Time"
        },
        "details": {
          "description": "Details provide additional information or metadata about the benchmark job.",
          "type": "string"
        },
        "failureMessage": {
          "description": "FailureMessage contains any error messages if the benchmark job failed.",
          "type": "string"
        },
        "lastReconcileTime": {
          "description": "LastReconcileTime is the timestamp for the last time the job was reconciled by the controller.",
          "$ref": "#/definitions/v1.Time"
        },
        "startTime": {
          "description": "StartTime is the timestamp for when the benchmark job started.",
          "$ref": "#/definitions/v1.Time"
        },
        "state": {
          "description": "State represents the current state of the benchmark job: \"Pending\", \"Running\", \"Completed\", \"Failed\".",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.BodyFilter": {
      "description": "BodyFilter defines body content filtering rules.",
      "type": "object",
      "required": [
        "type",
        "action"
      ],
      "properties": {
        "action": {
          "description": "Action defines the filtering action.",
          "type": "string",
          "default": ""
        },
        "pattern": {
          "description": "Pattern defines the pattern to match.",
          "type": "string"
        },
        "replacement": {
          "description": "Replacement defines the replacement value for redaction.",
          "type": "string"
        },
        "type": {
          "description": "Type defines the filter type.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.BuiltinPermissionProfile": {
      "description": "BuiltinPermissionProfile defines a built-in permission profile.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the built-in permission profile.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.CircuitBreakerConfig": {
      "description": "CircuitBreakerConfig defines circuit breaker configuration.",
      "type": "object",
      "properties": {
        "errorRateThreshold": {
          "description": "ErrorRateThreshold defines the error rate percentage to open the circuit.",
          "type": "string"
        },
        "failureThreshold": {
          "description": "FailureThreshold is the number of consecutive failures to open the circuit.",
          "type": "integer",
          "format": "int32"
        },
        "maxRequestsHalfOpen": {
          "description": "MaxRequestsHalfOpen is the maximum requests allowed in half-open state.",
          "type": "integer",
          "format": "int32"
        },
        "minRequestsThreshold": {
          "description": "MinRequestsThreshold is the minimum requests before error rate is calculated.",
          "type": "integer",
          "format": "int32"
        },
        "openStateTimeout": {
          "description": "OpenStateTimeout is the time to wait before transitioning to half-open.",
          "$ref": "#/definitions/v1.Duration"
        },
        "requestTimeout": {
          "description": "RequestTimeout defines the timeout for requests in various states.",
          "$ref": "#/definitions/v1.Duration"
        },
        "successThreshold": {
          "description": "SuccessThreshold is the number of consecutive successes to close the circuit.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ClientCertCredentials": {
      "description": "ClientCertCredentials defines client certificate authentication.",
      "type": "object",
      "required": [
        "certificateRef",
        "privateKeyRef"
      ],
      "properties": {
        "caRef": {
          "description": "CARef references the CA certificate secret for verification.",
          "$ref": "#/definitions/v1beta1.CredentialRef"
        },
        "certificateRef": {
          "description": "CertificateRef references the client certificate secret.",
          "default": {},
          "$ref": "#/definitions/v1beta1.CredentialRef"
        },
        "privateKeyRef": {
          "description": "PrivateKeyRef references the private key secret.",
          "default": {},
          "$ref": "#/definitions/v1beta1.CredentialRef"
        },
        "verifyServerCert": {
          "description": "VerifyServerCert controls whether to verify the server certificate.",
          "type": "boolean"
        }
      }
    },
    "v1beta1.ClusterBaseModel": {
      "description": "ClusterBaseModel is the Schema for the basemodels API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BaseModelSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.ClusterBaseModelList": {
      "description": "ClusterBaseModelList contains a list of ClusterBaseModel",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterBaseModel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ClusterMCPGateway": {
      "description": "ClusterMCPGateway is the cluster-scoped Schema for the mcpgateways API. ClusterMCPGateway provides AI-aware routing, context management, and federation capabilities for Model Context Protocol (MCP) servers across the entire cluster.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPGatewaySpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPGatewayStatus"
        }
      }
    },
    "v1beta1.ClusterMCPGatewayList": {
      "description": "ClusterMCPGatewayList contains a list of ClusterMCPGateway.",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterMCPGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ClusterMCPServer": {
      "description": "ClusterMCPServer is the cluster-scoped Schema for the mcpservers API",
      "type": "object",
      "required": [
        "spec"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPServerSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPServerStatus"
        }
      }
    },
    "v1beta1.ClusterMCPServerList": {
      "description": "ClusterMCPServerList contains a list of ClusterMCPServer",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterMCPServer"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ClusterServingRuntime": {
      "description": "ClusterServingRuntime is the Schema for the servingruntimes API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeStatus"
        }
      }
    },
    "v1beta1.ClusterServingRuntimeList": {
      "description": "ClusterServingRuntimeList contains a list of ServingRuntime",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterServingRuntime"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ComplianceConfig": {
      "description": "ComplianceConfig defines compliance-related policies.",
      "type": "object",
      "properties": {
        "dataRetention": {
          "description": "DataRetention defines data retention policies.",
          "$ref": "#/definitions/v1beta1.DataRetentionConfig"
        },
        "encryption": {
          "description": "Encryption defines encryption requirements.",
          "$ref": "#/definitions/v1beta1.ComplianceEncryptionConfig"
        },
        "piiDetection": {
          "description": "PIIDetection defines PII detection and handling.",
          "$ref": "#/definitions/v1beta1.PIIDetectionConfig"
        }
      }
    },
    "v1beta1.ComplianceEncryptionConfig": {
      "description": "ComplianceEncryptionConfig defines compliance encryption configuration.",
      "type": "object",
      "properties": {
        "encryptionAtRest": {
          "description": "EncryptionAtRest controls whether data must be encrypted at rest.",
          "type": "boolean"
        },
        "encryptionInTransit": {
          "description": "EncryptionInTransit controls whether data must be encrypted in transit.",
          "type": "boolean"
        },
        "requireEncryption": {
          "description": "RequireEncryption controls whether encryption is required.",
          "type": "boolean"
        }
      }
    },
    "v1beta1.ComponentExtensionSpec": {
      "description": "ComponentExtensionSpec defines the deployment configuration for a given InferenceService component",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "maxUnavailable": {
          "description": "MaxUnavailable specifies how many component pods can be unavailable",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ComponentStatusSpec": {
      "description": "ComponentStatusSpec describes the state of the component",
      "type": "object",
      "properties": {
        "address": {
          "description": "Addressable endpoint for the InferenceService",
          "$ref": "#/definitions/knative.Addressable"
        },
        "latestCreatedRevision": {
          "description": "Latest revision name that is created",
          "type": "string"
        },
        "latestReadyRevision": {
          "description": "Latest revision name that is in ready state",
          "type": "string"
        },
        "latestRolledoutRevision": {
          "description": "Latest revision name that is rolled out with 100 percent traffic",
          "type": "string"
        },
        "previousRolledoutRevision": {
          "description": "Previous revision name that is rolled out with 100 percent traffic",
          "type": "string"
        },
        "restURL": {
          "description": "REST endpoint of the component if available.",
          "$ref": "#/definitions/knative.URL"
        },
        "selectedAccelerator": {
          "description": "SelectedAccelerator shows which AcceleratorClass was selected",
          "$ref": "#/definitions/v1beta1.AcceleratorSelection"
        },
        "traffic": {
          "description": "Traffic holds the configured traffic distribution for latest ready revision and previous rolled out revision.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/knative.dev.serving.pkg.apis.serving.v1.TrafficTarget"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "url": {
          "description": "URL holds the primary url that will distribute traffic over the provided traffic targets. This will be one the REST or gRPC endpoints that are available. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
          "$ref": "#/definitions/knative.URL"
        }
      }
    },
    "v1beta1.ConfigValidationError": {
      "description": "ConfigValidationError represents a configuration validation error.",
      "type": "object",
      "required": [
        "field",
        "message",
        "severity"
      ],
      "properties": {
        "field": {
          "description": "Field is the configuration field that failed validation.",
          "type": "string",
          "default": ""
        },
        "message": {
          "description": "Message describes the validation error.",
          "type": "string",
          "default": ""
        },
        "severity": {
          "description": "Severity indicates the error severity.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ConfigValidationStatus": {
      "description": "ConfigValidationStatus provides configuration validation status.",
      "type": "object",
      "required": [
        "valid"
      ],
      "properties": {
        "lastValidated": {
          "description": "LastValidated is when the configuration was last validated.",
          "$ref": "#/definitions/v1.Time"
        },
        "valid": {
          "description": "Valid indicates whether the current configuration is valid.",
          "type": "boolean",
          "default": false
        },
        "validationErrors": {
          "description": "ValidationErrors contains any configuration validation errors.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ConfigValidationError"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "warnings": {
          "description": "Warnings contains non-blocking configuration warnings.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.CredentialRef": {
      "description": "CredentialRef provides a reference to a secret containing authentication credentials.",
      "type": "object",
      "properties": {
        "headerName": {
          "description": "HeaderName specifies the header name for API key authentication.",
          "type": "string"
        },
        "secretRef": {
          "description": "SecretRef references a Kubernetes secret containing the credential.",
          "$ref": "#/definitions/v1.SecretKeySelector"
        },
        "value": {
          "description": "Value contains the credential value directly (not recommended for sensitive data).",
          "type": "string"
        }
      }
    },
    "v1beta1.CustomMetric": {
      "description": "CustomMetric defines a custom metric to collect.",
      "type": "object",
      "required": [
        "name",
        "type"
      ],
      "properties": {
        "help": {
          "description": "Help provides a description of the metric.",
          "type": "string"
        },
        "labels": {
          "description": "Labels define metric labels.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "name": {
          "description": "Name is the metric name.",
          "type": "string",
          "default": ""
        },
        "type": {
          "description": "Type defines the metric type.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.DataRetentionConfig": {
      "description": "DataRetentionConfig defines data retention policies.",
      "type": "object",
      "properties": {
        "auditLogRetention": {
          "description": "AuditLogRetention defines how long to keep audit logs.",
          "$ref": "#/definitions/v1.Duration"
        },
        "contextRetention": {
          "description": "ContextRetention defines how long to keep context data.",
          "$ref": "#/definitions/v1.Duration"
        },
        "sessionRetention": {
          "description": "SessionRetention defines how long to keep session data.",
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.DecoderSpec": {
      "description": "DecoderSpec defines the configuration for the Decoder component (token generation in PD-disaggregated deployment) Used specifically for prefill-decode disaggregated deployments to handle the token generation phase. Similar to EngineSpec in structure, it allows for detailed pod and container configuration, but is specifically used for the decode phase when separating prefill and decode processes.",
      "type": "object",
      "properties": {
        "acceleratorOverride": {
          "description": "AcceleratorOverride allows overriding the global accelerator selection for this component",
          "$ref": "#/definitions/v1beta1.AcceleratorSelector"
        },
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "leader": {
          "description": "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed token generation in multi-node deployments.",
          "$ref": "#/definitions/v1beta1.LeaderSpec"
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "maxUnavailable": {
          "description": "MaxUnavailable specifies how many component pods can be unavailable",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Defines the main decoder container configuration, including image, resource requests/limits, environment variables, and command.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "worker": {
          "description": "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed token generation tasks as directed by the leader.",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.ElicitationPolicyConfig": {
      "description": "ElicitationPolicyConfig defines server-to-client elicitation request policy.",
      "type": "object",
      "properties": {
        "allowedTypes": {
          "description": "AllowedTypes defines which types of elicitation are allowed.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "enabled": {
          "description": "Enabled controls whether servers can request elicitation from clients.",
          "type": "boolean"
        },
        "maxConcurrentRequests": {
          "description": "MaxConcurrentRequests is the maximum concurrent elicitation requests.",
          "type": "integer",
          "format": "int32"
        },
        "requireConfirmation": {
          "description": "RequireConfirmation controls whether user confirmation is required for elicitation.",
          "type": "boolean"
        },
        "timeout": {
          "description": "Timeout defines the maximum time to wait for elicitation responses.",
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.Endpoint": {
      "description": "Endpoint defines a direct URL-based inference service with additional API configuration.",
      "type": "object",
      "required": [
        "url",
        "apiFormat"
      ],
      "properties": {
        "apiFormat": {
          "description": "APIFormat specifies the type of API, such as \"openai\" or \"oci-cohere\".",
          "type": "string",
          "default": ""
        },
        "modelName": {
          "description": "ModelName specifies the name of the model being served at the endpoint. Useful for endpoints that require model-specific configuration. For instance, for openai API, this is a required field in the payload",
          "type": "string"
        },
        "url": {
          "description": "URL represents the endpoint URL for the inference service.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.EndpointSpec": {
      "description": "EndpointSpec defines a reference to an inference service. It supports either a Kubernetes-style reference (InferenceService) or an Endpoint struct for a direct URL. Cross-namespace references are supported for InferenceService but require appropriate RBAC permissions to access resources in the target namespace.",
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Endpoint holds the details of a direct endpoint for an external inference service, including URL and API details.",
          "$ref": "#/definitions/v1beta1.Endpoint"
        },
        "inferenceService": {
          "description": "InferenceService holds a Kubernetes reference to an internal inference service.",
          "$ref": "#/definitions/v1beta1.InferenceServiceReference"
        }
      }
    },
    "v1beta1.EngineSpec": {
      "description": "EngineSpec defines the configuration for the Engine component (can be used for both single-node and multi-node deployments) Provides a comprehensive specification for deploying model serving containers and pods. It allows for complete Kubernetes pod configuration including main containers, init containers, sidecars, volumes, and other pod-level settings. For distributed deployments, it supports leader-worker architecture configuration.",
      "type": "object",
      "properties": {
        "acceleratorOverride": {
          "description": "AcceleratorOverride allows overriding the global accelerator selection for this component",
          "$ref": "#/definitions/v1beta1.AcceleratorSelector"
        },
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "leader": {
          "description": "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed inference in multi-node deployments.",
          "$ref": "#/definitions/v1beta1.LeaderSpec"
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "maxUnavailable": {
          "description": "MaxUnavailable specifies how many component pods can be unavailable",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the engine container This is essentially a container spec that can override the default container Defines the main model runner container configuration, including image, resource requests/limits, environment variables, and command.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "worker": {
          "description": "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed processing tasks as directed by the leader.",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.FailureInfo": {
      "type": "object",
      "properties": {
        "exitCode": {
          "description": "Exit status from the last termination of the container",
          "type": "integer",
          "format": "int32"
        },
        "location": {
          "description": "Name of component to which the failure relates (usually Pod name)",
          "type": "string"
        },
        "message": {
          "description": "Detailed error message",
          "type": "string"
        },
        "modelRevisionName": {
          "description": "Internal Revision/ID of model, tied to specific Spec contents",
          "type": "string"
        },
        "reason": {
          "description": "High level class of failure",
          "type": "string"
        },
        "time": {
          "description": "Time failure occurred or was discovered",
          "$ref": "#/definitions/v1.Time"
        }
      }
    },
    "v1beta1.FineTunedWeight": {
      "description": "FineTunedWeight is the Schema for the finetunedweights API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.FineTunedWeightSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.FineTunedWeightList": {
      "description": "FineTunedWeightList contains a list of FineTunedWeight",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.FineTunedWeight"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.FineTunedWeightSpec": {
      "description": "FineTunedWeightSpec defines the desired state of FineTunedWeight",
      "type": "object",
      "required": [
        "baseModelRef",
        "modelType",
        "hyperParameters",
        "storage"
      ],
      "properties": {
        "baseModelRef": {
          "description": "Reference to the base model that this weight is fine-tuned from",
          "default": {},
          "$ref": "#/definitions/v1beta1.ObjectReference"
        },
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "configuration": {
          "description": "Configuration of the fine-tuned weight, stored as generic JSON for flexibility",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "hyperParameters": {
          "description": "HyperParameters used for fine-tuning, stored as generic JSON for flexibility",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "modelType": {
          "description": "ModelType of the fine-tuned weight, e.g., \"Distillation\", \"Adapter\", \"Tfew\"",
          "type": "string"
        },
        "storage": {
          "description": "Storage configuration for the fine-tuned weight",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "trainingJobRef": {
          "description": "TrainingJobID is the ID of the training job that produced this weight",
          "default": {},
          "$ref": "#/definitions/v1beta1.ObjectReference"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.GRPCTransportConfig": {
      "description": "GRPCTransportConfig defines gRPC transport configuration.",
      "type": "object",
      "properties": {
        "connectionTimeout": {
          "description": "ConnectionTimeout defines the connection timeout.",
          "$ref": "#/definitions/v1.Duration"
        },
        "maxMessageSize": {
          "description": "MaxMessageSize defines the maximum message size.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "port": {
          "description": "Port defines the gRPC port.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.GatewayIngressConfig": {
      "description": "GatewayIngressConfig defines ingress configuration.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations define ingress annotations.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "className": {
          "description": "ClassName defines the ingress class name.",
          "type": "string"
        },
        "enabled": {
          "description": "Enabled controls whether ingress is created.",
          "type": "boolean"
        },
        "hosts": {
          "description": "Hosts define the ingress hosts.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.GatewayIngressHost"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tls": {
          "description": "TLS defines TLS configuration for ingress.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.GatewayIngressTLS"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.GatewayIngressHost": {
      "description": "GatewayIngressHost defines an ingress host.",
      "type": "object",
      "required": [
        "host"
      ],
      "properties": {
        "host": {
          "description": "Host is the host name.",
          "type": "string",
          "default": ""
        },
        "paths": {
          "description": "Paths define the host paths.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.GatewayIngressPath"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.GatewayIngressPath": {
      "description": "GatewayIngressPath defines an ingress path.",
      "type": "object",
      "required": [
        "path",
        "serviceName",
        "servicePort"
      ],
      "properties": {
        "path": {
          "description": "Path is the URL path.",
          "type": "string",
          "default": ""
        },
        "pathType": {
          "description": "PathType defines the path type.",
          "type": "string"
        },
        "serviceName": {
          "description": "ServiceName is the backend service name.",
          "type": "string",
          "default": ""
        },
        "servicePort": {
          "description": "ServicePort is the backend service port.",
          "type": "integer",
          "format": "int32",
          "default": 0
        }
      }
    },
    "v1beta1.GatewayIngressTLS": {
      "description": "GatewayIngressTLS defines ingress TLS configuration.",
      "type": "object",
      "properties": {
        "hosts": {
          "description": "Hosts define the TLS hosts.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "secretName": {
          "description": "SecretName references the TLS secret.",
          "type": "string"
        }
      }
    },
    "v1beta1.GatewayMetrics": {
      "description": "GatewayMetrics provides real-time performance metrics for the gateway.",
      "type": "object",
      "properties": {
        "activeConnections": {
          "description": "ActiveConnections is the number of currently active connections.",
          "type": "integer",
          "format": "int32"
        },
        "cacheHitRate": {
          "description": "CacheHitRate is the cache hit rate as a percentage.",
          "type": "string"
        },
        "errorRate": {
          "description": "ErrorRate is the current error rate as a percentage.",
          "type": "string"
        },
        "p50Latency": {
          "description": "P50Latency is the 50th percentile latency in milliseconds.",
          "type": "integer",
          "format": "int32"
        },
        "p90Latency": {
          "description": "P90Latency is the 99th percentile latency in milliseconds.",
          "type": "integer",
          "format": "int32"
        },
        "requestsPerSecond": {
          "description": "RequestsPerSecond is the current requests per second rate.",
          "type": "string"
        },
        "toolInvocations": {
          "description": "ToolInvocations tracks tool invocation statistics.",
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int64",
            "default": 0
          },
          "x-kubernetes-map-type": "atomic"
        }
      }
    },
    "v1beta1.GatewayServiceConfig": {
      "description": "GatewayServiceConfig defines service configuration.",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations define service annotations.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "ports": {
          "description": "Ports define the service ports.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.GatewayServicePort"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "type": {
          "description": "Type defines the service type.",
          "type": "string"
        }
      }
    },
    "v1beta1.GatewayServicePort": {
      "description": "GatewayServicePort defines a service port.",
      "type": "object",
      "required": [
        "name",
        "port"
      ],
      "properties": {
        "name": {
          "description": "Name is the port name.",
          "type": "string",
          "default": ""
        },
        "port": {
          "description": "Port is the service port.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "protocol": {
          "description": "Protocol is the port protocol.",
          "type": "string"
        },
        "targetPort": {
          "description": "TargetPort is the target port on pods.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.GatewayTransportConfig": {
      "description": "GatewayTransportConfig defines transport protocol configuration.",
      "type": "object",
      "properties": {
        "grpc": {
          "description": "GRPC defines gRPC transport configuration.",
          "$ref": "#/definitions/v1beta1.GRPCTransportConfig"
        },
        "http": {
          "description": "HTTP defines HTTP transport configuration.",
          "$ref": "#/definitions/v1beta1.HTTPTransportConfig"
        },
        "webSocket": {
          "description": "WebSocket defines WebSocket transport configuration.",
          "$ref": "#/definitions/v1beta1.WebSocketTransportConfig"
        }
      }
    },
    "v1beta1.HTTPTransportConfig": {
      "description": "HTTPTransportConfig defines HTTP transport configuration.",
      "type": "object",
      "properties": {
        "maxHeaderSize": {
          "description": "MaxHeaderSize defines the maximum header size.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "port": {
          "description": "Port defines the HTTP port.",
          "type": "integer",
          "format": "int32"
        },
        "readTimeout": {
          "description": "ReadTimeout defines the HTTP read timeout.",
          "$ref": "#/definitions/v1.Duration"
        },
        "writeTimeout": {
          "description": "WriteTimeout defines the HTTP write timeout.",
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.HeaderFilter": {
      "description": "HeaderFilter defines header filtering rules.",
      "type": "object",
      "required": [
        "name",
        "action"
      ],
      "properties": {
        "action": {
          "description": "Action defines the filtering action.",
          "type": "string",
          "default": ""
        },
        "name": {
          "description": "Name is the header name to filter.",
          "type": "string",
          "default": ""
        },
        "pattern": {
          "description": "Pattern is a regex pattern to match header values.",
          "type": "string"
        }
      }
    },
    "v1beta1.HealthCheckConfig": {
      "description": "HealthCheckConfig defines health checking configuration.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enabled controls whether health checking is performed.",
          "type": "boolean"
        },
        "healthyThreshold": {
          "description": "HealthyThreshold is the number of consecutive successes before marking healthy.",
          "type": "integer",
          "format": "int32"
        },
        "interval": {
          "description": "Interval is the time between health checks.",
          "$ref": "#/definitions/v1.Duration"
        },
        "timeout": {
          "description": "Timeout is the maximum time to wait for a health check response.",
          "$ref": "#/definitions/v1.Duration"
        },
        "unhealthyThreshold": {
          "description": "UnhealthyThreshold is the number of consecutive failures before marking unhealthy.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.HealthEndpointConfig": {
      "description": "HealthEndpointConfig defines health check endpoint configuration.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enabled controls whether health endpoints are exposed.",
          "type": "boolean"
        },
        "livenessPath": {
          "description": "LivenessPath defines the liveness probe path.",
          "type": "string"
        },
        "port": {
          "description": "Port defines the health endpoint port.",
          "type": "integer",
          "format": "int32"
        },
        "readinessPath": {
          "description": "ReadinessPath defines the readiness probe path.",
          "type": "string"
        }
      }
    },
    "v1beta1.HostedMCPServer": {
      "description": "HostedMCPServer defines a server that runs as pods in the cluster.",
      "type": "object",
      "required": [
        "podSpec"
      ],
      "properties": {
        "podSpec": {
          "description": "PodSpec defines the pod template to use for the MCP server.",
          "default": {},
          "$ref": "#/definitions/v1.PodTemplateSpec"
        },
        "replicas": {
          "description": "Replicas is the number of desired replicas for the server. Only applicable for servers with network-based transports (e.g., http, sse).",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.HuggingFaceSecretReference": {
      "description": "HuggingFaceSecretReference defines a reference to a Kubernetes Secret containing the Hugging Face API key. This secret must reside in the same namespace as the BenchmarkJob. Cross-namespace references are not allowed for security and simplicity.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the secret containing the Hugging Face API key. The secret must reside in the same namespace as the BenchmarkJob.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.InferenceService": {
      "description": "InferenceService is the Schema for the InferenceServices API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.InferenceServiceSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.InferenceServiceStatus"
        }
      }
    },
    "v1beta1.InferenceServiceList": {
      "description": "InferenceServiceList contains a list of Service",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.InferenceService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.InferenceServiceReference": {
      "description": "InferenceServiceReference defines the reference to a Kubernetes inference service.",
      "type": "object",
      "required": [
        "name",
        "namespace"
      ],
      "properties": {
        "name": {
          "description": "Name specifies the name of the inference service to benchmark.",
          "type": "string",
          "default": ""
        },
        "namespace": {
          "description": "Namespace specifies the Kubernetes namespace where the inference service is deployed. Cross-namespace references are allowed but require appropriate RBAC permissions.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.InferenceServiceSpec": {
      "description": "InferenceServiceSpec is the top level type for this resource",
      "type": "object",
      "properties": {
        "acceleratorSelector": {
          "description": "AcceleratorSelector specifies accelerator selection preferences",
          "$ref": "#/definitions/v1beta1.AcceleratorSelector"
        },
        "decoder": {
          "description": "Decoder defines the decoder spec This is specifically used for PD (Prefill-Decode) disaggregated serving deployments. Similar to Engine in structure, it allows for container and pod specifications, but is only utilized when implementing the disaggregated serving pattern to separate the prefill and decode phases of inference.",
          "$ref": "#/definitions/v1beta1.DecoderSpec"
        },
        "engine": {
          "description": "Engine defines the serving engine spec This provides detailed container and pod specifications for model serving. It allows defining the model runner (container spec), as well as complete pod specifications including init containers, sidecar containers, and other pod-level configurations. Engine can also be configured for multi-node deployments using leader and worker specifications.",
          "$ref": "#/definitions/v1beta1.EngineSpec"
        },
        "kedaConfig": {
          "description": "KedaConfig defines the autoscaling configuration for KEDA Provides settings for event-driven autoscaling using KEDA (Kubernetes Event-driven Autoscaling), allowing the service to scale based on custom metrics or event sources.",
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "model": {
          "description": "Model defines the model to be used for inference, referencing either a BaseModel or a custom model. This allows models to be managed independently of the serving configuration.",
          "$ref": "#/definitions/v1beta1.ModelRef"
        },
        "predictor": {
          "description": "Predictor defines the model serving spec It specifies how the model should be deployed and served, handling inference requests. Deprecated: Predictor is deprecated and will be removed in a future release. Please use Engine and Model fields instead.",
          "default": {},
          "$ref": "#/definitions/v1beta1.PredictorSpec"
        },
        "router": {
          "description": "Router defines the router spec",
          "$ref": "#/definitions/v1beta1.RouterSpec"
        },
        "runtime": {
          "description": "Runtime defines the serving runtime environment that will be used to execute the model. It is an inference service spec template that determines how the service should be deployed. Runtime is optional - if not defined, the operator will automatically select the best runtime based on the model's size, architecture, format, quantization, and framework.",
          "$ref": "#/definitions/v1beta1.ServingRuntimeRef"
        }
      }
    },
    "v1beta1.InferenceServiceStatus": {
      "description": "InferenceServiceStatus defines the observed state of InferenceService",
      "type": "object",
      "properties": {
        "address": {
          "description": "Addressable endpoint for the InferenceService",
          "$ref": "#/definitions/knative.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "components": {
          "description": "Statuses for the components of the InferenceService",
          "type": "object",
          "additionalProperties": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ComponentStatusSpec"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/knative.Condition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "modelStatus": {
          "description": "Model related statuses",
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatus"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "url": {
          "description": "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
          "$ref": "#/definitions/knative.URL"
        }
      }
    },
    "v1beta1.InlineAuthzConfig": {
      "description": "InlineAuthzConfig contains an embedded authorization policy.",
      "type": "object",
      "required": [
        "policies"
      ],
      "properties": {
        "entitiesJSON": {
          "description": "EntitiesJSON is a JSON string representing Cedar entities.",
          "type": "string"
        },
        "policies": {
          "description": "Policies is a list of Cedar policy strings.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.InlineOIDCConfig": {
      "description": "InlineOIDCConfig contains direct OIDC provider configuration.",
      "type": "object",
      "required": [
        "issuer"
      ],
      "properties": {
        "audience": {
          "description": "Audience is the expected audience for the token.",
          "type": "string"
        },
        "issuer": {
          "description": "Issuer is the OIDC issuer URL.",
          "type": "string",
          "default": ""
        },
        "jwksURL": {
          "description": "JWKSURL is the URL to fetch the JSON Web Key Set from. If empty, OIDC discovery will be used.",
          "type": "string"
        }
      }
    },
    "v1beta1.JWTCredentials": {
      "description": "JWTCredentials defines JWT authentication credentials.",
      "type": "object",
      "required": [
        "signingKey"
      ],
      "properties": {
        "algorithm": {
          "description": "Algorithm defines the JWT signing algorithm.",
          "type": "string"
        },
        "audience": {
          "description": "Audience defines the expected JWT audience.",
          "type": "string"
        },
        "expirationTolerance": {
          "description": "ExpirationTolerance defines tolerance for token expiration.",
          "$ref": "#/definitions/v1.Duration"
        },
        "issuer": {
          "description": "Issuer defines the expected JWT issuer.",
          "type": "string"
        },
        "signingKey": {
          "description": "SigningKey references the JWT signing key secret.",
          "default": {},
          "$ref": "#/definitions/v1beta1.CredentialRef"
        }
      }
    },
    "v1beta1.KedaConfig": {
      "description": "KedaConfig stores the configuration settings for KEDA autoscaling within the InferenceService. It includes fields like the Prometheus server address, custom query, scaling threshold, and operator.",
      "type": "object",
      "properties": {
        "customPromQuery": {
          "description": "CustomPromQuery defines a custom Prometheus query that KEDA will execute to evaluate the desired metric for scaling. This query should return a single numerical value that represents the metric to be monitored.\n\nExample:\n  avg_over_time(http_requests_total{service=\"llama\"}[5m])",
          "type": "string"
        },
        "enableKeda": {
          "description": "EnableKeda determines whether KEDA autoscaling is enabled for the InferenceService. - true: KEDA will manage the autoscaling based on the provided configuration. - false: KEDA will not be used, and autoscaling will rely on other mechanisms (e.g., HPA).",
          "type": "boolean"
        },
        "promServerAddress": {
          "description": "PromServerAddress specifies the address of the Prometheus server that KEDA will query to retrieve metrics for autoscaling decisions. This should be a fully qualified URL, including the protocol and port number.\n\nExample:\n  http://prometheus-operated.monitoring.svc.cluster.local:9090",
          "type": "string"
        },
        "scalingOperator": {
          "description": "ScalingOperator specifies the comparison operator used by KEDA to decide whether to scale the Deployment. Common operators include: - \"GreaterThanOrEqual\": Scale up when the metric is \u003e= ScalingThreshold. - \"LessThanOrEqual\": Scale down when the metric is \u003c= ScalingThreshold.\n\nThis operator defines the condition under which scaling actions are triggered based on the evaluated metric.\n\nExample:\n  \"GreaterThanOrEqual\"",
          "type": "string"
        },
        "scalingThreshold": {
          "description": "ScalingThreshold sets the numerical threshold against which the result of the Prometheus query will be compared. Depending on the ScalingOperator, this threshold determines when to scale the number of replicas up or down.\n\nExample:\n  \"10\" - The Autoscaler will compare the metric value to 10.",
          "type": "string"
        }
      }
    },
    "v1beta1.KubeResourcePermission": {
      "description": "KubeResourcePermission defines permissions for a set of Kubernetes resources.",
      "type": "object",
      "required": [
        "apiGroups",
        "resources",
        "verbs"
      ],
      "properties": {
        "apiGroups": {
          "description": "APIGroups is the list of API groups. \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "resources": {
          "description": "Resources is the list of resource names. \"*\" means all.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "verbs": {
          "description": "Verbs is the list of allowed verbs.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.KubernetesOIDCConfig": {
      "description": "KubernetesOIDCConfig configures OIDC for Kubernetes service account token validation.",
      "type": "object",
      "properties": {
        "issuer": {
          "description": "Issuer is the OIDC issuer URL of the Kubernetes cluster. If not specified, it defaults to the cluster's issuer URL.",
          "type": "string"
        }
      }
    },
    "v1beta1.LeaderSpec": {
      "description": "LeaderSpec defines the configuration for a leader node in a multi-node component The leader node coordinates the activities of worker nodes in distributed inference or token generation setups, handling task distribution and result aggregation.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the leader node's coordination logic.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.LogFileConfig": {
      "description": "LogFileConfig defines file-based logging configuration.",
      "type": "object",
      "required": [
        "path"
      ],
      "properties": {
        "compress": {
          "description": "Compress controls whether rotated logs are compressed.",
          "type": "boolean"
        },
        "maxFiles": {
          "description": "MaxFiles defines the maximum number of log files to keep.",
          "type": "integer",
          "format": "int32"
        },
        "maxSize": {
          "description": "MaxSize defines the maximum log file size before rotation.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "path": {
          "description": "Path defines the log file path.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.LoggingConfig": {
      "description": "LoggingConfig defines structured logging configuration.",
      "type": "object",
      "properties": {
        "file": {
          "description": "File defines file-based logging configuration.",
          "$ref": "#/definitions/v1beta1.LogFileConfig"
        },
        "format": {
          "description": "Format defines the log format.",
          "type": "string"
        },
        "level": {
          "description": "Level defines the logging level.",
          "type": "string"
        },
        "output": {
          "description": "Output defines where logs are sent.",
          "type": "string"
        }
      }
    },
    "v1beta1.MCPAuthenticationConfig": {
      "description": "MCPAuthenticationConfig defines simplified client authentication configuration.",
      "type": "object",
      "properties": {
        "default": {
          "description": "Default provides the default authentication method when none is specified.",
          "$ref": "#/definitions/v1beta1.AuthConfig"
        },
        "enabled": {
          "description": "Enabled controls whether authentication is required.",
          "type": "boolean"
        },
        "methods": {
          "description": "Methods define the supported authentication methods in order of preference.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.AuthConfig"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.MCPCapabilities": {
      "description": "MCPCapabilities defines the features supported by the MCP server.",
      "type": "object",
      "properties": {
        "prompts": {
          "description": "Prompts indicates whether the server supports prompt elicitation.",
          "type": "boolean"
        },
        "resources": {
          "description": "Resources indicates whether the server supports exposing resources.",
          "type": "boolean"
        },
        "tools": {
          "description": "Tools indicates whether the server supports tool execution.",
          "type": "boolean"
        }
      }
    },
    "v1beta1.MCPGateway": {
      "description": "MCPGateway is the Schema for the mcpgateways API. MCPGateway provides AI-aware routing, context management, and federation capabilities for Model Context Protocol (MCP) servers and tools.",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPGatewaySpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPGatewayStatus"
        }
      }
    },
    "v1beta1.MCPGatewayList": {
      "description": "MCPGatewayList contains a list of MCPGateway.",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.MCPGateway"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.MCPGatewayNetworkConfig": {
      "description": "GatewayNetworkConfig defines service exposure, transport protocols, and ingress settings.",
      "type": "object",
      "properties": {
        "ingress": {
          "description": "Ingress defines ingress configuration for external access.",
          "$ref": "#/definitions/v1beta1.GatewayIngressConfig"
        },
        "service": {
          "description": "Service defines the service configuration for the gateway.",
          "$ref": "#/definitions/v1beta1.GatewayServiceConfig"
        },
        "transport": {
          "description": "Transport defines the transport protocol configuration.",
          "$ref": "#/definitions/v1beta1.GatewayTransportConfig"
        }
      }
    },
    "v1beta1.MCPGatewayObservabilityConfig": {
      "description": "ObservabilityConfig defines monitoring, metrics, and tracing configuration.",
      "type": "object",
      "properties": {
        "health": {
          "description": "Health defines health check endpoint configuration.",
          "$ref": "#/definitions/v1beta1.HealthEndpointConfig"
        },
        "logging": {
          "description": "Logging defines structured logging configuration.",
          "$ref": "#/definitions/v1beta1.LoggingConfig"
        },
        "metrics": {
          "description": "Metrics defines metrics collection and export configuration.",
          "$ref": "#/definitions/v1beta1.MetricsConfig"
        },
        "tracing": {
          "description": "Tracing defines distributed tracing configuration.",
          "$ref": "#/definitions/v1beta1.TracingConfig"
        }
      }
    },
    "v1beta1.MCPGatewayPolicyConfig": {
      "description": "GatewayPolicyConfig defines unified security, authentication, authorization, and traffic policies.",
      "type": "object",
      "properties": {
        "audit": {
          "description": "Audit defines audit logging configuration.",
          "$ref": "#/definitions/v1beta1.AuditConfig"
        },
        "authentication": {
          "description": "Authentication defines client authentication configuration.",
          "$ref": "#/definitions/v1beta1.MCPAuthenticationConfig"
        },
        "circuitBreaker": {
          "description": "CircuitBreaker defines the circuit breaking configuration.",
          "$ref": "#/definitions/v1beta1.CircuitBreakerConfig"
        },
        "compliance": {
          "description": "Compliance defines compliance-related policies.",
          "$ref": "#/definitions/v1beta1.ComplianceConfig"
        },
        "elicitation": {
          "description": "Elicitation defines server-to-client elicitation request policy.",
          "$ref": "#/definitions/v1beta1.ElicitationPolicyConfig"
        },
        "rateLimit": {
          "description": "RateLimit defines rate limiting configuration.",
          "$ref": "#/definitions/v1beta1.RateLimitConfig"
        },
        "requestFiltering": {
          "description": "RequestFiltering defines request filtering policies.",
          "$ref": "#/definitions/v1beta1.RequestFilteringConfig"
        },
        "responseFiltering": {
          "description": "ResponseFiltering defines response filtering policies.",
          "$ref": "#/definitions/v1beta1.ResponseFilteringConfig"
        },
        "sampling": {
          "description": "Sampling defines server-to-client sampling request policy.",
          "$ref": "#/definitions/v1beta1.SamplingPolicyConfig"
        },
        "sessionIsolation": {
          "description": "SessionIsolation defines session isolation and context boundary policies.",
          "$ref": "#/definitions/v1beta1.SessionIsolationConfig"
        }
      }
    },
    "v1beta1.MCPGatewayServerStatus": {
      "description": "MCPGatewayServerStatus defines the status of a connected MCP server.",
      "type": "object",
      "required": [
        "name",
        "state"
      ],
      "properties": {
        "averageResponseTime": {
          "description": "AverageResponseTime is the average response time in milliseconds.",
          "type": "integer",
          "format": "int32"
        },
        "capabilities": {
          "description": "Capabilities are the server's current capabilities.",
          "$ref": "#/definitions/v1beta1.MCPCapabilities"
        },
        "circuitBreakerState": {
          "description": "CircuitBreakerState is the current circuit breaker state.",
          "type": "string"
        },
        "errorCount": {
          "description": "ErrorCount is the total number of errors from this server.",
          "type": "integer",
          "format": "int64"
        },
        "lastConnected": {
          "description": "LastConnected is the timestamp of the last successful connection.",
          "$ref": "#/definitions/v1.Time"
        },
        "lastError": {
          "description": "LastError contains the last error encountered.",
          "type": "string"
        },
        "name": {
          "description": "Name is the name of the MCP server.",
          "type": "string",
          "default": ""
        },
        "namespace": {
          "description": "Namespace is the namespace of the MCP server.",
          "type": "string"
        },
        "requestCount": {
          "description": "RequestCount is the total number of requests sent to this server.",
          "type": "integer",
          "format": "int64"
        },
        "state": {
          "description": "State is the current connection state.",
          "type": "string",
          "default": ""
        },
        "tags": {
          "description": "Tags are the current tags associated with this server.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "weight": {
          "description": "Weight is the current effective weight for load balancing.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.MCPGatewaySpec": {
      "description": "MCPGatewaySpec defines the desired state of MCPGateway. MCPGateway provides AI-aware routing, context management, and orchestration capabilities for Model Context Protocol (MCP) servers with federation support.",
      "type": "object",
      "required": [
        "mcpServers"
      ],
      "properties": {
        "mcpServers": {
          "description": "MCPServers defines how the gateway discovers and connects to MCP servers.",
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPServerDiscoveryConfig"
        },
        "network": {
          "description": "Network defines service exposure and ingress settings.",
          "$ref": "#/definitions/v1beta1.MCPGatewayNetworkConfig"
        },
        "observability": {
          "description": "Observability defines monitoring, metrics, and tracing configuration.",
          "$ref": "#/definitions/v1beta1.MCPGatewayObservabilityConfig"
        },
        "podSpec": {
          "description": "PodSpec defines the pod template for the gateway deployment.",
          "$ref": "#/definitions/v1.PodTemplateSpec"
        },
        "policy": {
          "description": "Policy defines unified security, authentication, authorization, and traffic policies.",
          "$ref": "#/definitions/v1beta1.MCPGatewayPolicyConfig"
        },
        "protocolVersion": {
          "description": "ProtocolVersion defines MCP protocol version constraints and negotiation settings.",
          "$ref": "#/definitions/v1beta1.MCPProtocolVersionConfig"
        },
        "replicas": {
          "description": "Replicas is the number of desired replicas for the gateway.",
          "type": "integer",
          "format": "int32"
        },
        "transport": {
          "description": "Transport defines the supported transport protocols for MCP communication.",
          "type": "string"
        }
      }
    },
    "v1beta1.MCPGatewayStatus": {
      "description": "MCPGatewayStatus defines the observed state of MCPGateway.",
      "type": "object",
      "properties": {
        "activeSessions": {
          "description": "ActiveSessions is the current number of active sessions.",
          "type": "integer",
          "format": "int32"
        },
        "availableReplicas": {
          "description": "AvailableReplicas is the number of available replicas.",
          "type": "integer",
          "format": "int32"
        },
        "averageLatency": {
          "description": "AverageLatency is the average request latency in milliseconds.",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Conditions represent the latest available observations of the MCPGateway's state.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Condition"
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "configStatus": {
          "description": "ConfigStatus provides configuration validation status.",
          "$ref": "#/definitions/v1beta1.ConfigValidationStatus"
        },
        "connectedServers": {
          "description": "ConnectedServers is the list of currently connected servers.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.MCPGatewayServerStatus"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "lastUpdateTime": {
          "description": "LastUpdateTime is the last time the status was updated.",
          "$ref": "#/definitions/v1.Time"
        },
        "metrics": {
          "description": "Metrics provides real-time performance metrics.",
          "$ref": "#/definitions/v1beta1.GatewayMetrics"
        },
        "observedGeneration": {
          "description": "ObservedGeneration reflects the generation most recently observed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "phase": {
          "description": "Phase is the current phase of the MCPGateway lifecycle.",
          "type": "string"
        },
        "promptRegistry": {
          "description": "PromptRegistry provides status of the prompt registry.",
          "$ref": "#/definitions/v1beta1.PromptRegistryStatus"
        },
        "readyReplicas": {
          "description": "ReadyReplicas is the number of ready replicas.",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the most recently observed number of replicas.",
          "type": "integer",
          "format": "int32"
        },
        "resourceRegistry": {
          "description": "ResourceRegistry provides status of the resource registry.",
          "$ref": "#/definitions/v1beta1.ResourceRegistryStatus"
        },
        "resourceUsage": {
          "description": "ResourceUsage provides current resource utilization information.",
          "$ref": "#/definitions/v1beta1.ResourceUsageStatus"
        },
        "serverStatusSummary": {
          "description": "ServerStatusSummary provides an aggregated summary of server statuses.",
          "$ref": "#/definitions/v1beta1.ServerStatusSummary"
        },
        "serviceURL": {
          "description": "ServiceURL is the URL where the gateway service can be accessed.",
          "type": "string"
        },
        "toolRegistry": {
          "description": "ToolRegistry provides status of the tool registry.",
          "$ref": "#/definitions/v1beta1.ToolRegistryStatus"
        },
        "totalErrors": {
          "description": "TotalErrors is the total number of errors encountered.",
          "type": "integer",
          "format": "int64"
        },
        "totalRequests": {
          "description": "TotalRequests is the total number of requests processed.",
          "type": "integer",
          "format": "int64"
        },
        "unhealthyServers": {
          "description": "UnhealthyServers lists servers that are currently unhealthy.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.MCPGatewayServerStatus"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "workflowStatus": {
          "description": "WorkflowStatus provides status of workflow orchestration.",
          "$ref": "#/definitions/v1beta1.WorkflowStatus"
        }
      }
    },
    "v1beta1.MCPProtocolVersionConfig": {
      "description": "MCPProtocolVersionConfig defines MCP protocol version constraints and negotiation settings.",
      "type": "object",
      "properties": {
        "allowVersionNegotiation": {
          "description": "AllowVersionNegotiation controls whether version negotiation is allowed.",
          "type": "boolean"
        },
        "maxVersion": {
          "description": "MaxVersion defines the maximum acceptable MCP protocol version.",
          "type": "string"
        },
        "minVersion": {
          "description": "MinVersion defines the minimum acceptable MCP protocol version.",
          "type": "string"
        },
        "preferredVersion": {
          "description": "PreferredVersion defines the preferred protocol version for new connections.",
          "type": "string"
        },
        "strictVersioning": {
          "description": "StrictVersioning controls whether to reject connections with unsupported versions.",
          "type": "boolean"
        },
        "supported": {
          "description": "Supported defines the list of supported MCP protocol versions. If empty, the gateway will support all known versions.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.MCPServer": {
      "description": "MCPServer is the Schema for the mcpservers API",
      "type": "object",
      "required": [
        "spec"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPServerSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.MCPServerStatus"
        }
      }
    },
    "v1beta1.MCPServerDiscoveryConfig": {
      "description": "MCPServerDiscoveryConfig defines how the gateway discovers and connects to MCP servers.",
      "type": "object",
      "properties": {
        "autoDiscovery": {
          "description": "AutoDiscovery enables automatic discovery of MCP servers through federation.",
          "type": "boolean"
        },
        "healthCheck": {
          "description": "HealthCheck defines health checking configuration for discovered servers.",
          "$ref": "#/definitions/v1beta1.HealthCheckConfig"
        },
        "namespaceSelector": {
          "description": "NamespaceSelector restricts server discovery to specific namespaces. Only applicable when using Selector. If empty, searches all accessible namespaces.",
          "$ref": "#/definitions/v1.LabelSelector"
        },
        "selector": {
          "description": "Selector allows dynamic discovery of MCPServer resources using a label selector.",
          "$ref": "#/definitions/v1.LabelSelector"
        },
        "static": {
          "description": "Static provides a fixed list of MCP server references.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.MCPServerRef"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.MCPServerList": {
      "description": "MCPServerList contains a list of MCPServer",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.MCPServer"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.MCPServerRef": {
      "description": "MCPServerRef defines a reference to an upstream MCP server with routing parameters.",
      "type": "object",
      "properties": {
        "auth": {
          "description": "Auth defines the credentials for this specific server.",
          "$ref": "#/definitions/v1beta1.AuthConfig"
        },
        "capabilities": {
          "description": "Capabilities override the server's advertised capabilities for routing.",
          "$ref": "#/definitions/v1beta1.MCPCapabilities"
        },
        "name": {
          "description": "Name of the referenced MCPServer resource.",
          "type": "string",
          "default": ""
        },
        "namespace": {
          "description": "Namespace of the referenced MCPServer resource. If empty, assumes the gateway's namespace.",
          "type": "string"
        },
        "priority": {
          "description": "Priority for server selection (lower value is higher priority).",
          "type": "integer",
          "format": "int32"
        },
        "tags": {
          "description": "Tags define semantic tags for routing decisions.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "transport": {
          "description": "Transport override for this specific server.",
          "type": "string"
        }
      }
    },
    "v1beta1.MCPServerSpec": {
      "description": "MCPServerSpec defines the desired state of an MCPServer. An MCPServer can either be 'Hosted' within the cluster or a 'Remote' external service.",
      "type": "object",
      "properties": {
        "authzConfig": {
          "description": "AuthzConfig defines authorization policies for the server.",
          "$ref": "#/definitions/v1beta1.AuthzConfigSource"
        },
        "capabilities": {
          "description": "Capabilities defines the features supported by this server.",
          "$ref": "#/definitions/v1beta1.MCPCapabilities"
        },
        "hosted": {
          "description": "Hosted defines a server that runs as pods within the cluster.",
          "$ref": "#/definitions/v1beta1.HostedMCPServer"
        },
        "oidcConfig": {
          "description": "OIDCConfig defines OIDC authentication for authenticating clients.",
          "$ref": "#/definitions/v1beta1.OIDCConfigSource"
        },
        "permissionProfile": {
          "description": "PermissionProfile defines the operational permissions for the server.",
          "$ref": "#/definitions/v1beta1.PermissionProfileSource"
        },
        "remote": {
          "description": "Remote defines a server that is accessed via an external URL.",
          "$ref": "#/definitions/v1beta1.RemoteMCPServer"
        },
        "toolsFilter": {
          "description": "ToolsFilter restricts the tools exposed by this server.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "transport": {
          "description": "Transport specifies the transport protocol for MCP communication.",
          "type": "string"
        },
        "version": {
          "description": "Version of the MCP server software.",
          "type": "string"
        }
      }
    },
    "v1beta1.MCPServerStatus": {
      "description": "MCPServerStatus defines the observed state of MCPServer",
      "type": "object",
      "properties": {
        "conditions": {
          "description": "Conditions represent the latest available observations of the MCPServer's state Standard condition types: Ready, Available, Progressing",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Condition"
          },
          "x-kubernetes-list-map-keys": [
            "type"
          ],
          "x-kubernetes-list-type": "map"
        },
        "lastUpdateTime": {
          "description": "LastUpdateTime is the last time the status was updated",
          "$ref": "#/definitions/v1.Time"
        },
        "message": {
          "description": "Message provides additional information about the current phase",
          "type": "string"
        },
        "observedGeneration": {
          "description": "ObservedGeneration reflects the generation most recently observed by the controller",
          "type": "integer",
          "format": "int64"
        },
        "phase": {
          "description": "Phase is the current phase of the MCPServer lifecycle",
          "type": "string"
        },
        "readyReplicas": {
          "description": "ReadyReplicas is the number of ready replicas for hosted servers",
          "type": "integer",
          "format": "int32"
        },
        "replicas": {
          "description": "Replicas is the most recently observed number of replicas for hosted servers",
          "type": "integer",
          "format": "int32"
        },
        "url": {
          "description": "URL is the URL where the MCP server can be accessed For Hosted servers, this is the cluster-internal or external service URL For Remote servers, this reflects the configured external URL",
          "type": "string"
        }
      }
    },
    "v1beta1.MetricsConfig": {
      "description": "MetricsConfig defines metrics collection and export configuration.",
      "type": "object",
      "properties": {
        "customMetrics": {
          "description": "CustomMetrics define additional custom metrics to collect.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.CustomMetric"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "enabled": {
          "description": "Enabled controls whether metrics collection is active.",
          "type": "boolean"
        },
        "format": {
          "description": "Format defines the metrics format.",
          "type": "string"
        },
        "path": {
          "description": "Path defines the metrics endpoint path.",
          "type": "string"
        },
        "port": {
          "description": "Port defines the metrics endpoint port.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ModelCopies": {
      "type": "object",
      "required": [
        "failedCopies"
      ],
      "properties": {
        "failedCopies": {
          "description": "How many copies of this predictor's models failed to load recently",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "totalCopies": {
          "description": "Total number copies of this predictor's models that are currently loaded",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ModelExtensionSpec": {
      "type": "object",
      "properties": {
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.ModelFormat": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the format in which the model is stored, e.g., \"ONNX\", \"TensorFlow SavedModel\", \"PyTorch\", \"SafeTensors\"",
          "type": "string",
          "default": ""
        },
        "operator": {
          "description": "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFormat version",
          "type": "string"
        },
        "version": {
          "description": "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        },
        "weight": {
          "description": "Weight of the model format in the runtime selector, used to prioritize modelFormat",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ModelFrameworkSpec": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the library in which the model is stored, e.g., \"ONNXRuntime\", \"TensorFlow\", \"PyTorch\", \"Transformer\", \"TensorRTLLM\"",
          "type": "string",
          "default": ""
        },
        "operator": {
          "description": "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFramework version",
          "type": "string"
        },
        "version": {
          "description": "Version of the library. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        },
        "weight": {
          "description": "Weight of the framework in the runtime selector, used to prioritize modelFramework",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ModelRef": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "description": "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced model.",
          "type": "string"
        },
        "fineTunedWeights": {
          "description": "Optional FineTunedWeights references References to fine-tuned weights that should be applied to the base model.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "kind": {
          "description": "Kind of the model being referenced Defaults to ClusterBaseModel Specifies the Kubernetes resource kind of the referenced model.",
          "type": "string"
        },
        "name": {
          "description": "Name of the model being referenced Identifies the specific model to be used for inference.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ModelRevisionStates": {
      "type": "object",
      "required": [
        "activeModelState"
      ],
      "properties": {
        "activeModelState": {
          "description": "High level state string: Pending, Standby, Loading, Loaded, FailedToLoad",
          "type": "string",
          "default": ""
        },
        "targetModelState": {
          "type": "string"
        }
      }
    },
    "v1beta1.ModelSizeRangeSpec": {
      "description": "ModelSizeRangeSpec defines the range of model sizes supported by this runtime",
      "type": "object",
      "properties": {
        "max": {
          "description": "Maximum size of the model in bytes",
          "type": "string"
        },
        "min": {
          "description": "Minimum size of the model in bytes",
          "type": "string"
        }
      }
    },
    "v1beta1.ModelSpec": {
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "baseModel": {
          "type": "string"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "fineTunedWeights": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "protocolVersion": {
          "description": "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
          "type": "string"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "runtime": {
          "description": "Specific ClusterServingRuntime/ServingRuntime name to use for deployment.",
          "type": "string"
        },
        "runtimeVersion": {
          "description": "Runtime version of the predictor docker image",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "storageUri": {
          "description": "This field points to the location of the model which is mounted onto the pod.",
          "type": "string"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.ModelStatus": {
      "type": "object",
      "required": [
        "transitionStatus"
      ],
      "properties": {
        "lastFailureInfo": {
          "description": "Details of last failure, when load of target model is failed or blocked.",
          "$ref": "#/definitions/v1beta1.FailureInfo"
        },
        "modelCopies": {
          "description": "Model copy information of the predictor's model.",
          "$ref": "#/definitions/v1beta1.ModelCopies"
        },
        "modelRevisionStates": {
          "description": "State information of the predictor's model.",
          "$ref": "#/definitions/v1beta1.ModelRevisionStates"
        },
        "transitionStatus": {
          "description": "Whether the available predictor endpoints reflect the current Spec or is in transition",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ModelStatusSpec": {
      "description": "ModelStatusSpec defines the observed state of Model weight",
      "type": "object",
      "required": [
        "state"
      ],
      "properties": {
        "lifecycle": {
          "description": "LifeCycle is an enum of Deprecated, Experiment, Public, Internal",
          "type": "string"
        },
        "nodesFailed": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodesReady": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "state": {
          "description": "Status of the model weight",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.NetworkPermission": {
      "description": "NetworkPermission defines outbound network permissions.",
      "type": "object",
      "required": [
        "allowHost"
      ],
      "properties": {
        "allowHost": {
          "description": "AllowHost is a list of glob patterns for hosts to allow connections to.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.NetworkUsageInfo": {
      "description": "NetworkUsageInfo provides network usage information.",
      "type": "object",
      "required": [
        "bytesIn",
        "bytesOut",
        "connectionsPerSecond"
      ],
      "properties": {
        "bytesIn": {
          "description": "BytesIn is the total bytes received.",
          "type": "integer",
          "format": "int64",
          "default": 0
        },
        "bytesOut": {
          "description": "BytesOut is the total bytes sent.",
          "type": "integer",
          "format": "int64",
          "default": 0
        },
        "connectionsPerSecond": {
          "description": "ConnectionsPerSecond is the rate of new connections.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.OAuth2Credentials": {
      "description": "OAuth2Credentials defines OAuth2 authentication credentials.",
      "type": "object",
      "required": [
        "clientID",
        "clientSecret",
        "tokenURL"
      ],
      "properties": {
        "clientID": {
          "description": "ClientID for OAuth2 authentication.",
          "type": "string",
          "default": ""
        },
        "clientSecret": {
          "description": "ClientSecret references the OAuth2 client secret.",
          "default": {},
          "$ref": "#/definitions/v1beta1.CredentialRef"
        },
        "scopes": {
          "description": "Scopes define the OAuth2 scopes to request.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "tokenURL": {
          "description": "TokenURL is the OAuth2 token endpoint.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.OIDCConfigSource": {
      "description": "OIDCConfigSource defines the source of OIDC configuration. Only one of the fields may be set.",
      "type": "object",
      "properties": {
        "inline": {
          "description": "Inline contains a direct OIDC provider configuration.",
          "$ref": "#/definitions/v1beta1.InlineOIDCConfig"
        },
        "kubernetes": {
          "description": "Kubernetes configures OIDC to validate Kubernetes service account tokens.",
          "$ref": "#/definitions/v1beta1.KubernetesOIDCConfig"
        }
      }
    },
    "v1beta1.ObjectReference": {
      "description": "ObjectReference contains enough information to let you inspect or modify the referred object.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the referenced object",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referenced object",
          "type": "string"
        }
      }
    },
    "v1beta1.PIIDetectionConfig": {
      "description": "PIIDetectionConfig defines PII detection and handling.",
      "type": "object",
      "properties": {
        "action": {
          "description": "Action defines the action to take when PII is detected.",
          "type": "string"
        },
        "enabled": {
          "description": "Enabled controls whether PII detection is active.",
          "type": "boolean"
        },
        "patterns": {
          "description": "Patterns define PII detection patterns.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.PIIPattern"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.PIIPattern": {
      "description": "PIIPattern defines a PII detection pattern.",
      "type": "object",
      "required": [
        "type"
      ],
      "properties": {
        "description": {
          "description": "Description provides a human-readable description.",
          "type": "string"
        },
        "pattern": {
          "description": "Pattern is a regex pattern for custom PII detection.",
          "type": "string"
        },
        "type": {
          "description": "Type defines the PII type.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.PermissionProfileSource": {
      "description": "PermissionProfileSource defines the source of a permission profile. Only one of the fields may be set.",
      "type": "object",
      "properties": {
        "builtin": {
          "description": "Builtin selects a pre-defined, named permission profile.",
          "$ref": "#/definitions/v1beta1.BuiltinPermissionProfile"
        },
        "configMap": {
          "description": "ConfigMap references a ConfigMap containing a permission profile specification.",
          "$ref": "#/definitions/v1.ConfigMapKeySelector"
        },
        "inline": {
          "description": "Inline contains an embedded permission profile specification.",
          "$ref": "#/definitions/v1beta1.PermissionProfileSpec"
        }
      }
    },
    "v1beta1.PermissionProfileSpec": {
      "description": "PermissionProfileSpec defines the permissions for an MCP server.",
      "type": "object",
      "required": [
        "allow"
      ],
      "properties": {
        "allow": {
          "description": "Allow specifies the permissions granted to the server.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.PermissionRule"
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.PermissionRule": {
      "description": "PermissionRule defines a single permission grant.",
      "type": "object",
      "properties": {
        "kubeResources": {
          "description": "KubeResources defines permissions for accessing Kubernetes resources.",
          "$ref": "#/definitions/v1beta1.KubeResourcePermission"
        },
        "network": {
          "description": "Network defines permissions for making outbound network calls.",
          "$ref": "#/definitions/v1beta1.NetworkPermission"
        }
      }
    },
    "v1beta1.PodOverride": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "env": {
          "description": "List of environment variables to set in the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Image specifies the container image to use for the benchmark job.",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.PodSpec": {
      "description": "PodSpec is a description of a pod.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.PredictorExtensionSpec": {
      "description": "PredictorExtensionSpec defines configuration shared across all predictor frameworks",
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "protocolVersion": {
          "description": "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
          "type": "string"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "runtimeVersion": {
          "description": "Runtime version of the predictor docker image",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "storageUri": {
          "description": "This field points to the location of the model which is mounted onto the pod.",
          "type": "string"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.PredictorSpec": {
      "description": "PredictorSpec defines the configuration for a predictor, The following fields follow a \"1-of\" semantic. Users must specify exactly one spec.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "maxUnavailable": {
          "description": "MaxUnavailable specifies how many component pods can be unavailable",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "model": {
          "description": "Model spec for any arbitrary framework.",
          "$ref": "#/definitions/v1beta1.ModelSpec"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "workerSpec": {
          "description": "WorkerSpec for the predictor, this is used for multi-node serving without Ray Cluster",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.PromptRegistryStatus": {
      "description": "PromptRegistryStatus provides status of the prompt registry.",
      "type": "object",
      "properties": {
        "lastUpdated": {
          "description": "LastUpdated is when the registry was last updated.",
          "$ref": "#/definitions/v1.Time"
        },
        "totalPrompts": {
          "description": "TotalPrompts is the total number of registered prompts.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.RateLimitConfig": {
      "description": "RateLimitConfig defines rate limiting policies.",
      "type": "object",
      "properties": {
        "global": {
          "description": "Global rate limit applied to all requests.",
          "$ref": "#/definitions/v1beta1.RateLimitPolicy"
        },
        "perIP": {
          "description": "PerIP defines rate limits per client IP address.",
          "$ref": "#/definitions/v1beta1.RateLimitPolicy"
        },
        "perServer": {
          "description": "PerServer defines rate limits per upstream server.",
          "$ref": "#/definitions/v1beta1.RateLimitPolicy"
        },
        "perUser": {
          "description": "PerUser defines rate limits per authenticated user.",
          "$ref": "#/definitions/v1beta1.RateLimitPolicy"
        }
      }
    },
    "v1beta1.RateLimitPolicy": {
      "description": "RateLimitPolicy defines a rate limiting policy.",
      "type": "object",
      "properties": {
        "burst": {
          "description": "Burst is the burst capacity for rate limiting.",
          "type": "integer",
          "format": "int32"
        },
        "requestsPerHour": {
          "description": "RequestsPerHour is the number of requests allowed per hour.",
          "type": "integer",
          "format": "int32"
        },
        "requestsPerMinute": {
          "description": "RequestsPerMinute is the number of requests allowed per minute.",
          "type": "integer",
          "format": "int32"
        },
        "requestsPerSecond": {
          "description": "RequestsPerSecond is the number of requests allowed per second.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.RemoteMCPServer": {
      "description": "RemoteMCPServer defines a server that is accessed via an external URL.",
      "type": "object",
      "required": [
        "url"
      ],
      "properties": {
        "url": {
          "description": "URL is the external URL of the remote MCP server.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.RequestFilteringConfig": {
      "description": "RequestFilteringConfig defines request filtering policies.",
      "type": "object",
      "properties": {
        "bodyFilters": {
          "description": "BodyFilters define body content filtering rules.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BodyFilter"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "contentTypeFilter": {
          "description": "ContentTypeFilter defines allowed content types.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "headerFilters": {
          "description": "HeaderFilters define header filtering rules.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.HeaderFilter"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "sizeLimit": {
          "description": "SizeLimit defines maximum request size.",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.ResourceRegistryStatus": {
      "description": "ResourceRegistryStatus provides status of the resource registry.",
      "type": "object",
      "properties": {
        "cacheHitRate": {
          "description": "CacheHitRate is the resource cache hit rate as a percentage.",
          "type": "string"
        },
        "lastUpdated": {
          "description": "LastUpdated is when the registry was last updated.",
          "$ref": "#/definitions/v1.Time"
        },
        "totalResources": {
          "description": "TotalResources is the total number of registered resources.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ResourceUsageStatus": {
      "description": "ResourceUsageStatus provides current resource utilization information.",
      "type": "object",
      "properties": {
        "cpuUsage": {
          "description": "CPU usage as a percentage of allocated resources.",
          "type": "string"
        },
        "memoryUsage": {
          "description": "Memory usage as a percentage of allocated resources.",
          "type": "string"
        },
        "networkUsage": {
          "description": "Network usage statistics.",
          "$ref": "#/definitions/v1beta1.NetworkUsageInfo"
        },
        "storageUsage": {
          "description": "Storage usage for context and cache storage.",
          "$ref": "#/definitions/v1beta1.StorageUsageInfo"
        }
      }
    },
    "v1beta1.ResponseFilteringConfig": {
      "description": "ResponseFilteringConfig defines response filtering policies.",
      "type": "object",
      "properties": {
        "bodyFilters": {
          "description": "BodyFilters define response body filtering rules.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BodyFilter"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "headerFilters": {
          "description": "HeaderFilters define response header filtering rules.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.HeaderFilter"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "removeInternalHeaders": {
          "description": "RemoveInternalHeaders controls whether to remove internal headers.",
          "type": "boolean"
        },
        "sizeLimit": {
          "description": "SizeLimit defines maximum response size.",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.RouterSpec": {
      "description": "RouterSpec defines the configuration for the Router component, which handles request routing",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "config": {
          "description": "Additional configuration parameters for the runner This can include framework-specific settings",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be added to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "maxUnavailable": {
          "description": "MaxUnavailable specifies how many component pods can be unavailable",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minAvailable": {
          "description": "MinAvailiable specifies how many component pods must still be aviliable after the eviction",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.util.intstr.IntOrString"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "This is essentially a container spec that can override the default container",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.RunnerSpec": {
      "description": "RunnerSpec defines container configuration plus additional config settings The Runner is the primary container that executes the model serving or token generation logic.",
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.SamplingPolicyConfig": {
      "description": "SamplingPolicyConfig defines server-to-client sampling request policy.",
      "type": "object",
      "properties": {
        "clientModel": {
          "description": "ClientModel defines which AI model to use for sampling requests.",
          "type": "string"
        },
        "enabled": {
          "description": "Enabled controls whether servers can request sampling from clients.",
          "type": "boolean"
        },
        "maxTokens": {
          "description": "MaxTokens defines the maximum tokens for sampling requests.",
          "type": "integer",
          "format": "int32"
        },
        "rateLimit": {
          "description": "RateLimit defines rate limiting for sampling requests.",
          "$ref": "#/definitions/v1beta1.SamplingRateLimit"
        },
        "temperature": {
          "description": "Temperature controls the randomness of sampling responses.",
          "type": "string"
        },
        "timeout": {
          "description": "Timeout defines the maximum time to wait for sampling responses.",
          "$ref": "#/definitions/v1.Duration"
        }
      }
    },
    "v1beta1.SamplingRateLimit": {
      "description": "SamplingRateLimit defines rate limiting for sampling requests.",
      "type": "object",
      "properties": {
        "requestsPerHour": {
          "description": "RequestsPerHour is the maximum sampling requests per hour.",
          "type": "integer",
          "format": "int32"
        },
        "requestsPerMinute": {
          "description": "RequestsPerMinute is the maximum sampling requests per minute.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ServerStatusSummary": {
      "description": "ServerStatusSummary provides an aggregated summary of server statuses.",
      "type": "object",
      "required": [
        "total",
        "connected",
        "disconnected",
        "unhealthy",
        "circuitOpen"
      ],
      "properties": {
        "circuitOpen": {
          "description": "Number of servers with open circuit breakers.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "connected": {
          "description": "Number of servers that are connected and healthy.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "disconnected": {
          "description": "Number of servers that are disconnected.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "total": {
          "description": "Total number of configured servers.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "unhealthy": {
          "description": "Number of servers that are unhealthy.",
          "type": "integer",
          "format": "int32",
          "default": 0
        }
      }
    },
    "v1beta1.ServiceMetadata": {
      "description": "ServiceMetadata contains metadata fields for recording the backend model server's configuration and version details. This information helps track experiment context, enabling users to filter and query experiments based on server properties.",
      "type": "object",
      "required": [
        "engine",
        "version",
        "gpuType",
        "gpuCount"
      ],
      "properties": {
        "engine": {
          "description": "Engine specifies the backend model server engine. Supported values: \"vLLM\", \"SGLang\", \"TGI\".",
          "type": "string",
          "default": ""
        },
        "gpuCount": {
          "description": "GpuCount indicates the number of GPU cards available on the model server.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "gpuType": {
          "description": "GpuType specifies the type of GPU used by the model server. Supported values: \"H100\", \"A100\", \"MI300\", \"A10\".",
          "type": "string",
          "default": ""
        },
        "version": {
          "description": "Version specifies the version of the model server (e.g., \"0.5.3\").",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ServingRuntime": {
      "description": "ServingRuntime is the Schema for the servingruntimes API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeStatus"
        }
      }
    },
    "v1beta1.ServingRuntimeList": {
      "description": "ServingRuntimeList contains a list of ServingRuntime",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ServingRuntime"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ServingRuntimePodSpec": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.ServingRuntimeRef": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "description": "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced runtime.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the runtime being referenced Defaults to ClusterServingRuntime Specifies the Kubernetes resource kind of the referenced runtime. ClusterServingRuntime is a cluster-wide runtime, while ServingRuntime is namespace-scoped.",
          "type": "string"
        },
        "name": {
          "description": "Name of the runtime being referenced Identifies the specific runtime environment to be used for model execution.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ServingRuntimeSpec": {
      "description": "ServingRuntimeSpec defines the desired state of ServingRuntime. This spec is currently provisional and are subject to change as details regarding single-model serving and multi-model serving are hammered out.",
      "type": "object",
      "properties": {
        "acceleratorRequirements": {
          "description": "AcceleratorRequirements specifies the accelerator requirements for this runtime",
          "$ref": "#/definitions/v1beta1.AcceleratorRequirements"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "decoderConfig": {
          "description": "Decoder configuration for this runtime",
          "$ref": "#/definitions/v1beta1.DecoderSpec"
        },
        "disabled": {
          "description": "Set to true to disable use of this runtime",
          "type": "boolean"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "engineConfig": {
          "description": "Engine configuration for this runtime",
          "$ref": "#/definitions/v1beta1.EngineSpec"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "modelSizeRange": {
          "description": "ModelSizeRange is the range of model sizes supported by this runtime",
          "$ref": "#/definitions/v1beta1.ModelSizeRangeSpec"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "protocolVersions": {
          "description": "Supported protocol versions (i.e. openAI or cohere or openInference-v1 or openInference-v2)",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "routerConfig": {
          "description": "Router configuration for this runtime",
          "$ref": "#/definitions/v1beta1.RouterSpec"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "supportedModelFormats": {
          "description": "Model formats and version supported by this runtime",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.SupportedModelFormat"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "workers": {
          "description": "WorkerPodSpec for the serving runtime, this is used for multi-node serving without Ray Cluster",
          "$ref": "#/definitions/v1beta1.WorkerPodSpec"
        }
      }
    },
    "v1beta1.ServingRuntimeStatus": {
      "description": "ServingRuntimeStatus defines the observed state of ServingRuntime",
      "type": "object"
    },
    "v1beta1.SessionIsolationConfig": {
      "description": "SessionIsolationConfig defines session isolation and context boundary policies.",
      "type": "object",
      "properties": {
        "allowedCrossSessionData": {
          "description": "AllowedCrossSessionData defines what data types can be shared across sessions when enabled.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        },
        "auditLevel": {
          "description": "AuditLevel defines the audit logging level for session boundaries.",
          "type": "string"
        },
        "contextRetention": {
          "description": "ContextRetention defines how long session context is retained.",
          "$ref": "#/definitions/v1.Duration"
        },
        "crossSessionSharing": {
          "description": "CrossSessionSharing controls whether data can be shared between sessions.",
          "type": "boolean"
        },
        "enforceResourceBoundaries": {
          "description": "EnforceResourceBoundaries controls whether resource access is strictly bounded per session.",
          "type": "boolean"
        },
        "mode": {
          "description": "Mode defines the isolation level for MCP sessions.",
          "type": "string"
        }
      }
    },
    "v1beta1.StorageMetrics": {
      "description": "StorageMetrics provides storage metrics.",
      "type": "object",
      "required": [
        "used",
        "available",
        "usagePercent"
      ],
      "properties": {
        "available": {
          "description": "Available storage in bytes.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "usagePercent": {
          "description": "Usage percentage.",
          "type": "string",
          "default": ""
        },
        "used": {
          "description": "Used storage in bytes.",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.StorageSpec": {
      "type": "object",
      "required": [
        "storageUri"
      ],
      "properties": {
        "key": {
          "description": "StorageKey is the name of the key in a Kubernetes Secret used to authenticate access to the model storage. This key will be used to fetch credentials during model download or access.",
          "type": "string"
        },
        "nodeAffinity": {
          "description": "NodeAffinity describes the node affinity rules that further constrain which nodes are eligible to download and store this model, based on advanced scheduling policies.",
          "$ref": "#/definitions/v1.NodeAffinity"
        },
        "nodeSelector": {
          "description": "NodeSelector defines a set of key-value label pairs that must be present on a node for the model to be scheduled and downloaded onto that node.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "parameters": {
          "description": "Parameters contain key-value pairs to override default storage credentials or configuration. These values are typically used to configure access to object storage or mount options.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "path": {
          "description": "Path is the absolute path where the model will be downloaded and stored on the node.",
          "type": "string"
        },
        "schemaPath": {
          "description": "SchemaPath is the path to the model schema or configuration file within the storage system. This can be used to validate the model or customize how it's loaded.",
          "type": "string"
        },
        "storageUri": {
          "description": "StorageUri specifies the source URI of the model in a supported storage backend. Supported formats: - OCI Object Storage:   oci://n/{namespace}/b/{bucket}/o/{object_path} - Persistent Volume:    pvc://{pvc-name}/{sub-path} - Vendor-specific:      vendor://{vendor-name}/{resource-type}/{resource-path} This field is required.",
          "type": "string"
        }
      }
    },
    "v1beta1.StorageUsageInfo": {
      "description": "StorageUsageInfo provides storage usage information.",
      "type": "object",
      "properties": {
        "cacheStorage": {
          "description": "CacheStorage usage information.",
          "$ref": "#/definitions/v1beta1.StorageMetrics"
        },
        "contextStorage": {
          "description": "ContextStorage usage information.",
          "$ref": "#/definitions/v1beta1.StorageMetrics"
        }
      }
    },
    "v1beta1.SupportedModelFormat": {
      "type": "object",
      "required": [
        "modelFormat",
        "modelFramework"
      ],
      "properties": {
        "acceleratorConfig": {
          "description": "AcceleratorConfig provides accelerator-specific overrides for this model format",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1beta1.AcceleratorModelConfig"
          }
        },
        "autoSelect": {
          "description": "Set to true to allow the ServingRuntime to be used for automatic model placement if this model format is specified with no explicit runtime.",
          "type": "boolean"
        },
        "modelArchitecture": {
          "description": "ModelArchitecture of the model, e.g., \"LlamaForCausalLM\", \"GemmaForCausalLM\", \"MixtralForCausalLM\"",
          "type": "string"
        },
        "modelFormat": {
          "description": "ModelFormat of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"SafeTensors\"",
          "$ref": "#/definitions/v1beta1.ModelFormat"
        },
        "modelFramework": {
          "description": "ModelFramework of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"Transformers\"",
          "$ref": "#/definitions/v1beta1.ModelFrameworkSpec"
        },
        "modelType": {
          "description": "DEPRECATED: This field is deprecated and will be removed in future releases.",
          "type": "string"
        },
        "name": {
          "description": "Name of the model",
          "type": "string",
          "default": ""
        },
        "priority": {
          "description": "Priority of this serving runtime for auto selection. This is used to select the serving runtime if more than one serving runtime supports the same model format. The value should be greater than zero.  The higher the value, the higher the priority. Priority is not considered if AutoSelect is either false or not specified. Priority can be overridden by specifying the runtime in the InferenceService.",
          "type": "integer",
          "format": "int32"
        },
        "quantization": {
          "description": "Quantization of the model, e.g., \"fp8\", \"fbgemm_fp8\", \"int4\"",
          "type": "string"
        },
        "version": {
          "description": "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        }
      }
    },
    "v1beta1.SupportedRuntime": {
      "description": "SupportedRuntime is the schema for supported runtime result of automatic selection",
      "type": "object",
      "required": [
        "Name",
        "Spec"
      ],
      "properties": {
        "Name": {
          "type": "string",
          "default": ""
        },
        "Spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        }
      }
    },
    "v1beta1.TensorParallelismConfig": {
      "description": "TensorParallelismConfig specifies tensor parallelism settings",
      "type": "object",
      "properties": {
        "dataParallelSize": {
          "description": "dataParallelSize specifies the size of the data parallelism",
          "type": "integer",
          "format": "int64"
        },
        "pipelineParallelSize": {
          "description": "pipelineParallelSize specifies the size of the pipeline parallelism",
          "type": "integer",
          "format": "int64"
        },
        "tensorParallelSize": {
          "description": "tensorParallelSize specifies the size of the tensor parallelism",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ToolRegistryStatus": {
      "description": "ToolRegistryStatus provides status of the tool registry.",
      "type": "object",
      "properties": {
        "lastUpdated": {
          "description": "LastUpdated is when the registry was last updated.",
          "$ref": "#/definitions/v1.Time"
        },
        "mcpTools": {
          "description": "MCPTools is the number of native MCP tools.",
          "type": "integer",
          "format": "int32"
        },
        "restTools": {
          "description": "RestTools is the number of virtualized REST API tools.",
          "type": "integer",
          "format": "int32"
        },
        "totalTools": {
          "description": "TotalTools is the total number of registered tools.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.TracingConfig": {
      "description": "TracingConfig defines distributed tracing configuration.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Enabled controls whether distributed tracing is active.",
          "type": "boolean"
        },
        "endpoint": {
          "description": "Endpoint defines the tracing collector endpoint.",
          "type": "string"
        },
        "headers": {
          "description": "Headers define additional headers to send with traces.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "provider": {
          "description": "Provider defines the tracing backend provider.",
          "type": "string"
        },
        "samplingRate": {
          "description": "SamplingRate defines the sampling rate for traces (0.0-1.0).",
          "type": "string"
        }
      }
    },
    "v1beta1.WebSocketTransportConfig": {
      "description": "WebSocketTransportConfig defines WebSocket transport configuration.",
      "type": "object",
      "properties": {
        "pingInterval": {
          "description": "PingInterval defines the ping interval for keep-alive.",
          "$ref": "#/definitions/v1.Duration"
        },
        "port": {
          "description": "Port defines the WebSocket port.",
          "type": "integer",
          "format": "int32"
        },
        "readBufferSize": {
          "description": "ReadBufferSize defines the read buffer size.",
          "$ref": "#/definitions/resource.Quantity"
        },
        "writeBufferSize": {
          "description": "WriteBufferSize defines the write buffer size.",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.WorkerPodSpec": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "size": {
          "description": "Size of the worker, this is the number of pods in the worker.",
          "type": "integer",
          "format": "int32"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.WorkerSpec": {
      "description": "WorkerSpec defines the configuration for worker nodes in a multi-node component Worker nodes perform the distributed processing tasks assigned by the leader node, enabling horizontal scaling for compute-intensive workloads.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the worker node's processing logic.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "size": {
          "description": "Size of the worker, this is the number of pods in the worker. Controls how many worker pod instances will be deployed for horizontal scaling.",
          "type": "integer",
          "format": "int32"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.WorkflowStatus": {
      "description": "WorkflowStatus provides status of workflow orchestration.",
      "type": "object",
      "properties": {
        "activeWorkflows": {
          "description": "ActiveWorkflows is the number of currently active workflows.",
          "type": "integer",
          "format": "int32"
        },
        "averageExecutionTime": {
          "description": "AverageExecutionTime is the average workflow execution time in seconds.",
          "type": "string"
        },
        "completedWorkflows": {
          "description": "CompletedWorkflows is the total number of completed workflows.",
          "type": "integer",
          "format": "int64"
        },
        "failedWorkflows": {
          "description": "FailedWorkflows is the total number of failed workflows.",
          "type": "integer",
          "format": "int64"
        }
      }
    }
  }
}
