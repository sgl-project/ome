{
  "swagger": "2.0",
  "info": {
    "description": "Python SDK for OME",
    "title": "OME",
    "version": "v0.1"
  },
  "paths": {},
  "definitions": {
    "v1beta1.AcceleratorCapabilities": {
      "type": "object",
      "properties": {
        "clockSpeedMHz": {
          "description": "Clock speeds",
          "type": "integer",
          "format": "int32"
        },
        "computeCapability": {
          "description": "Compute capability (NVIDIA) or equivalent",
          "type": "string"
        },
        "features": {
          "description": "Features supported by this accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "levelZeroVersion": {
          "description": "Level Zero version (for Intel accelerators)",
          "type": "string"
        },
        "memoryBandwidthGBps": {
          "description": "Memory bandwidth",
          "$ref": "#/definitions/resource.Quantity"
        },
        "memoryGB": {
          "description": "Memory capacity in GB",
          "$ref": "#/definitions/resource.Quantity"
        },
        "performance": {
          "description": "Performance metrics",
          "$ref": "#/definitions/v1beta1.AcceleratorPerformance"
        }
      }
    },
    "v1beta1.AcceleratorClass": {
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorClassSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorClassStatus"
        }
      }
    },
    "v1beta1.AcceleratorClassList": {
      "description": "AcceleratorClassList contains a list of AcceleratorClass",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.AcceleratorClass"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.AcceleratorClassSpec": {
      "type": "object",
      "required": [
        "discovery",
        "capabilities"
      ],
      "properties": {
        "capabilities": {
          "description": "Capabilities of this accelerator class",
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorCapabilities"
        },
        "cost": {
          "description": "Cost information for optimization decisions",
          "$ref": "#/definitions/v1beta1.AcceleratorCost"
        },
        "discovery": {
          "description": "Discovery patterns to identify nodes with this accelerator",
          "default": {},
          "$ref": "#/definitions/v1beta1.AcceleratorDiscovery"
        },
        "family": {
          "description": "Family of the accelerator (ampere, hopper, cdna2, etc.)",
          "type": "string"
        },
        "integration": {
          "description": "Integration with external systems",
          "$ref": "#/definitions/v1beta1.AcceleratorIntegration"
        },
        "model": {
          "description": "Model name (a100, h100, mi250x, etc.)",
          "type": "string"
        },
        "resources": {
          "description": "Resources exposed by this accelerator",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.AcceleratorResource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "vendor": {
          "description": "Vendor of the accelerator (nvidia, amd, intel, etc.)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorClassStatus": {
      "type": "object",
      "properties": {
        "availableAccelerators": {
          "description": "Available accelerators (not allocated)",
          "type": "integer",
          "format": "int32"
        },
        "availableNodes": {
          "description": "AvailableNodes is the number of nodes that have this accelerator available",
          "type": "integer",
          "format": "int32"
        },
        "conditions": {
          "description": "Conditions represent the latest available observations",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Condition"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "lastUpdated": {
          "description": "Last update time",
          "$ref": "#/definitions/v1.Time"
        },
        "nodes": {
          "description": "Nodes that have this accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "totalAccelerators": {
          "description": "Total number of accelerators in the cluster",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.AcceleratorCost": {
      "type": "object",
      "properties": {
        "perHour": {
          "description": "Cost per hour in dollars",
          "$ref": "#/definitions/resource.Quantity"
        },
        "perMillionTokens": {
          "description": "Cost per million tokens (for usage-based pricing)",
          "$ref": "#/definitions/resource.Quantity"
        },
        "spotPerHour": {
          "description": "Spot instance pricing if available",
          "$ref": "#/definitions/resource.Quantity"
        },
        "tier": {
          "description": "Cost tier for simplified selection (low, medium, high)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorDiscovery": {
      "type": "object",
      "properties": {
        "deviceIDs": {
          "description": "DeviceIDs list of PCI device IDs",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodeSelector": {
          "description": "NodeSelector to identify nodes with this accelerator",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelectorTerms": {
          "description": "NodeSelectorTerms for more complex node selection",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.NodeSelectorTerm"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "pciVendorID": {
          "description": "PCIVendorID for device discovery (e.g., \"10de\" for NVIDIA)",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorIntegration": {
      "type": "object",
      "properties": {
        "kueueResourceFlavor": {
          "description": "KueueResourceFlavor name to sync with",
          "type": "string"
        },
        "volcanoGPUType": {
          "description": "VolcanoGPUType for Volcano integration",
          "type": "string"
        }
      }
    },
    "v1beta1.AcceleratorLatency": {
      "type": "object",
      "properties": {
        "averageMillis": {
          "description": "Average latency in milliseconds",
          "type": "integer",
          "format": "int64"
        },
        "maximumMillis": {
          "description": "Maximum latency in milliseconds",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.AcceleratorModelConfig": {
      "description": "AcceleratorModelConfig provides accelerator-specific overrides for this model format",
      "type": "object",
      "properties": {
        "environmentOverride": {
          "description": "EnvironmentOverride provides accelerator-specific environment variables",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "minMemoryPerBillionParams": {
          "description": "MinMemoryPerBillionParams specifies memory required per billion parameters Used to calculate if a model fits on the accelerator",
          "type": "integer",
          "format": "int64"
        },
        "runtimeArgsOverride": {
          "description": "RuntimeArgsOverride provides accelerator-specific runtime arguments",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tensorParallelismOverride": {
          "description": "TensorParallelismOverride overrides the default tensor parallelism settings",
          "$ref": "#/definitions/v1beta1.TensorParallelismConfig"
        }
      }
    },
    "v1beta1.AcceleratorPerformance": {
      "type": "object",
      "properties": {
        "fp16Tflops": {
          "description": "FP16 performance in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "fp32Tflops": {
          "description": "FP32 performance in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "int4Tops": {
          "description": "INT4 performance in TOPS",
          "type": "integer",
          "format": "int64"
        },
        "int8Tops": {
          "description": "INT8 performance in TOPS",
          "type": "integer",
          "format": "int64"
        },
        "latency": {
          "description": "Latency metrics",
          "$ref": "#/definitions/v1beta1.AcceleratorLatency"
        }
      }
    },
    "v1beta1.AcceleratorRequirements": {
      "description": "AcceleratorRequirements specifies the accelerator requirements for this runtime",
      "type": "object",
      "properties": {
        "acceleratorClasses": {
          "description": "AcceleratorClasses lists the names of AcceleratorClasses this runtime supports If empty, the runtime supports any accelerator",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "minComputeCapability": {
          "description": "MinComputeCapability specifies minimum compute capability in TFLOPS",
          "type": "integer",
          "format": "int64"
        },
        "minMemory": {
          "description": "MinMemory specifies minimum GPU memory required in GB",
          "type": "integer",
          "format": "int64"
        },
        "preferredPrecisions": {
          "description": "PreferredPrecisions lists numeric precisions in order of preference Examples: [\"fp8\", \"fp16\", \"fp32\"]",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "requiredFeatures": {
          "description": "RequiredFeatures lists hardware features that must be present Examples: [\"tensor-cores\", \"fp8\", \"nvlink\"]",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        }
      }
    },
    "v1beta1.AcceleratorResource": {
      "type": "object",
      "required": [
        "name",
        "quantity"
      ],
      "properties": {
        "divisible": {
          "description": "Divisible indicates if the resource can be subdivided",
          "type": "boolean"
        },
        "name": {
          "description": "Name of the resource (e.g., nvidia.com/gpu)",
          "type": "string",
          "default": ""
        },
        "quantity": {
          "description": "Quantity per accelerator",
          "$ref": "#/definitions/resource.Quantity"
        }
      }
    },
    "v1beta1.BaseModel": {
      "description": "BaseModel is the Schema for the basemodels API",
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BaseModelSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.BaseModelList": {
      "description": "BaseModelList contains a list of BaseModel",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BaseModel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.BaseModelSpec": {
      "description": "BaseModelSpec defines the desired state of BaseModel",
      "type": "object",
      "required": [
        "storage"
      ],
      "properties": {
        "additionalMetadata": {
          "description": "Additional metadata for the model",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "maxTokens": {
          "description": "MaxTokens is the maximum number of tokens that can be processed by the model",
          "type": "integer",
          "format": "int32"
        },
        "modelArchitecture": {
          "description": "ModelArchitecture specifies the concrete model implementation or head, such as \"LlamaForCausalLM\", \"GemmaForCausalLM\", or \"MixtralForCausalLM\". This is often derived from the \"architectures\" field in Hugging Face config.json.",
          "type": "string"
        },
        "modelCapabilities": {
          "description": "ModelCapabilities of the model, e.g., \"TEXT_GENERATION\", \"TEXT_SUMMARIZATION\", \"TEXT_EMBEDDINGS\"",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "modelConfiguration": {
          "description": "Configuration of the model, stored as generic JSON for flexibility.",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "modelFormat": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelFormat"
        },
        "modelFramework": {
          "description": "ModelFramework specifies the underlying framework used by the model, such as \"ONNX\", \"TensorFlow\", \"PyTorch\", \"Transformer\", or \"TensorRTLLM\". This value helps determine the appropriate runtime for model serving.",
          "$ref": "#/definitions/v1beta1.ModelFrameworkSpec"
        },
        "modelParameterSize": {
          "description": "ModelParameterSize indicates the total number of parameters in the model, expressed in human-readable form such as \"7B\", \"13B\", or \"175B\". This can be used for scheduling or runtime selection.",
          "type": "string"
        },
        "modelType": {
          "description": "ModelType defines the architecture family of the model (e.g., \"bert\", \"gpt2\", \"llama\"). This value typically corresponds to the \"model_type\" field in a Hugging Face model's config.json. It is used to identify the transformer architecture and inform runtime selection and tokenizer behavior.",
          "type": "string"
        },
        "quantization": {
          "description": "Quantization defines the quantization scheme applied to the model weights, such as \"fp8\", \"fbgemm_fp8\", or \"int4\". This influences runtime compatibility and performance.",
          "type": "string"
        },
        "servingMode": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "storage": {
          "description": "Storage configuration for the model",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.BenchmarkJob": {
      "description": "BenchmarkJob is the schema for the BenchmarkJobs API",
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BenchmarkJobSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BenchmarkJobStatus"
        }
      }
    },
    "v1beta1.BenchmarkJobList": {
      "description": "BenchmarkJobList contains a list of BenchmarkJob",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.BenchmarkJob"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.BenchmarkJobSpec": {
      "description": "BenchmarkJobSpec defines the specification for a benchmark job. All fields within this specification collectively represent the desired state and configuration of a BenchmarkJob.",
      "type": "object",
      "required": [
        "endpoint",
        "task",
        "maxTimePerIteration",
        "maxRequestsPerIteration",
        "outputLocation"
      ],
      "properties": {
        "additionalRequestParams": {
          "description": "AdditionalRequestParams contains additional request parameters as a map.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "dataset": {
          "description": "Dataset is the dataset used for benchmarking. It is optional and only required for tasks other than \"text-to-\u003coutput-modality\u003e\".",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "endpoint": {
          "description": "Endpoint is the reference to the inference service to benchmark.",
          "default": {},
          "$ref": "#/definitions/v1beta1.EndpointSpec"
        },
        "huggingFaceSecretReference": {
          "description": "HuggingFaceSecretReference is a reference to a Kubernetes Secret containing the Hugging Face API key. The referenced Secret must reside in the same namespace as the BenchmarkJob. This field replaces the raw HuggingFaceAPIKey field for improved security.",
          "$ref": "#/definitions/v1beta1.HuggingFaceSecretReference"
        },
        "maxRequestsPerIteration": {
          "description": "MaxRequestsPerIteration specifies the maximum number of requests for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
          "type": "integer",
          "format": "int32"
        },
        "maxTimePerIteration": {
          "description": "MaxTimePerIteration specifies the maximum time (in minutes) for a single iteration. Each iteration runs for a specific combination of TrafficScenarios and NumConcurrency.",
          "type": "integer",
          "format": "int32"
        },
        "numConcurrency": {
          "description": "NumConcurrency defines a list of concurrency levels to test during the benchmark. If not provided, defaults will be assigned via genai-bench.",
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int32",
            "default": 0
          },
          "x-kubernetes-list-type": "set"
        },
        "outputLocation": {
          "description": "OutputLocation specifies where the benchmark results will be stored (e.g., object storage).",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "podOverride": {
          "description": "Pod defines the pod configuration for the benchmark job. This is optional, if not provided, default values will be used.",
          "$ref": "#/definitions/v1beta1.PodOverride"
        },
        "resultFolderName": {
          "description": "ResultFolderName specifies the name of the folder that stores the benchmark result. A default name will be assigned if not specified.",
          "type": "string"
        },
        "serviceMetadata": {
          "description": "ServiceMetadata records metadata about the backend model server or service being benchmarked. This includes details such as server engine, version, and GPU configuration for filtering experiments.",
          "$ref": "#/definitions/v1beta1.ServiceMetadata"
        },
        "task": {
          "description": "Task specifies the task to benchmark, pattern: \u003cinput-modality\u003e-to-\u003coutput-modality\u003e (e.g., \"text-to-text\", \"image-to-text\").",
          "type": "string",
          "default": ""
        },
        "trafficScenarios": {
          "description": "TrafficScenarios contains a list of traffic scenarios to simulate during the benchmark. If not provided, defaults will be assigned via genai-bench.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "set"
        }
      }
    },
    "v1beta1.BenchmarkJobStatus": {
      "description": "BenchmarkJobStatus reflects the state and results of the benchmark job. It will be set and updated by the controller.",
      "type": "object",
      "required": [
        "state"
      ],
      "properties": {
        "completionTime": {
          "description": "CompletionTime is the timestamp for when the benchmark job completed, either successfully or unsuccessfully.",
          "$ref": "#/definitions/v1.Time"
        },
        "details": {
          "description": "Details provide additional information or metadata about the benchmark job.",
          "type": "string"
        },
        "failureMessage": {
          "description": "FailureMessage contains any error messages if the benchmark job failed.",
          "type": "string"
        },
        "lastReconcileTime": {
          "description": "LastReconcileTime is the timestamp for the last time the job was reconciled by the controller.",
          "$ref": "#/definitions/v1.Time"
        },
        "startTime": {
          "description": "StartTime is the timestamp for when the benchmark job started.",
          "$ref": "#/definitions/v1.Time"
        },
        "state": {
          "description": "State represents the current state of the benchmark job: \"Pending\", \"Running\", \"Completed\", \"Failed\".",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ClusterBaseModel": {
      "description": "ClusterBaseModel is the Schema for the basemodels API",
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.BaseModelSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.ClusterBaseModelList": {
      "description": "ClusterBaseModelList contains a list of ClusterBaseModel",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterBaseModel"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ClusterServingRuntime": {
      "description": "ClusterServingRuntime is the Schema for the servingruntimes API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeStatus"
        }
      }
    },
    "v1beta1.ClusterServingRuntimeList": {
      "description": "ClusterServingRuntimeList contains a list of ServingRuntime",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ClusterServingRuntime"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ComponentExtensionSpec": {
      "description": "ComponentExtensionSpec defines the deployment configuration for a given InferenceService component",
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ComponentStatusSpec": {
      "description": "ComponentStatusSpec describes the state of the component",
      "type": "object",
      "properties": {
        "address": {
          "description": "Addressable endpoint for the InferenceService",
          "$ref": "#/definitions/knative.Addressable"
        },
        "latestCreatedRevision": {
          "description": "Latest revision name that is created",
          "type": "string"
        },
        "latestReadyRevision": {
          "description": "Latest revision name that is in ready state",
          "type": "string"
        },
        "latestRolledoutRevision": {
          "description": "Latest revision name that is rolled out with 100 percent traffic",
          "type": "string"
        },
        "previousRolledoutRevision": {
          "description": "Previous revision name that is rolled out with 100 percent traffic",
          "type": "string"
        },
        "restURL": {
          "description": "REST endpoint of the component if available.",
          "$ref": "#/definitions/knative.URL"
        },
        "traffic": {
          "description": "Traffic holds the configured traffic distribution for latest ready revision and previous rolled out revision.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/knative.dev.serving.pkg.apis.serving.v1.TrafficTarget"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "url": {
          "description": "URL holds the primary url that will distribute traffic over the provided traffic targets. This will be one the REST or gRPC endpoints that are available. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
          "$ref": "#/definitions/knative.URL"
        }
      }
    },
    "v1beta1.DecoderSpec": {
      "description": "DecoderSpec defines the configuration for the Decoder component (token generation in PD-disaggregated deployment) Used specifically for prefill-decode disaggregated deployments to handle the token generation phase. Similar to EngineSpec in structure, it allows for detailed pod and container configuration, but is specifically used for the decode phase when separating prefill and decode processes.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "leader": {
          "description": "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed token generation in multi-node deployments.",
          "$ref": "#/definitions/v1beta1.LeaderSpec"
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Defines the main decoder container configuration, including image, resource requests/limits, environment variables, and command.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "worker": {
          "description": "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed token generation tasks as directed by the leader.",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.Endpoint": {
      "description": "Endpoint defines a direct URL-based inference service with additional API configuration.",
      "type": "object",
      "required": [
        "url",
        "apiFormat"
      ],
      "properties": {
        "apiFormat": {
          "description": "APIFormat specifies the type of API, such as \"openai\" or \"oci-cohere\".",
          "type": "string",
          "default": ""
        },
        "modelName": {
          "description": "ModelName specifies the name of the model being served at the endpoint. Useful for endpoints that require model-specific configuration. For instance, for openai API, this is a required field in the payload",
          "type": "string"
        },
        "url": {
          "description": "URL represents the endpoint URL for the inference service.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.EndpointSpec": {
      "description": "EndpointSpec defines a reference to an inference service. It supports either a Kubernetes-style reference (InferenceService) or an Endpoint struct for a direct URL. Cross-namespace references are supported for InferenceService but require appropriate RBAC permissions to access resources in the target namespace.",
      "type": "object",
      "properties": {
        "endpoint": {
          "description": "Endpoint holds the details of a direct endpoint for an external inference service, including URL and API details.",
          "$ref": "#/definitions/v1beta1.Endpoint"
        },
        "inferenceService": {
          "description": "InferenceService holds a Kubernetes reference to an internal inference service.",
          "$ref": "#/definitions/v1beta1.InferenceServiceReference"
        }
      }
    },
    "v1beta1.EngineSpec": {
      "description": "EngineSpec defines the configuration for the Engine component (can be used for both single-node and multi-node deployments) Provides a comprehensive specification for deploying model serving containers and pods. It allows for complete Kubernetes pod configuration including main containers, init containers, sidecars, volumes, and other pod-level settings. For distributed deployments, it supports leader-worker architecture configuration.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "leader": {
          "description": "Leader node configuration (only used for MultiNode deployment) Defines the pod and container spec for the leader node that coordinates distributed inference in multi-node deployments.",
          "$ref": "#/definitions/v1beta1.LeaderSpec"
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the engine container This is essentially a container spec that can override the default container Defines the main model runner container configuration, including image, resource requests/limits, environment variables, and command.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "worker": {
          "description": "Worker nodes configuration (only used for MultiNode deployment) Defines the pod and container spec for worker nodes that perform distributed processing tasks as directed by the leader.",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.FailureInfo": {
      "type": "object",
      "properties": {
        "exitCode": {
          "description": "Exit status from the last termination of the container",
          "type": "integer",
          "format": "int32"
        },
        "location": {
          "description": "Name of component to which the failure relates (usually Pod name)",
          "type": "string"
        },
        "message": {
          "description": "Detailed error message",
          "type": "string"
        },
        "modelRevisionName": {
          "description": "Internal Revision/ID of model, tied to specific Spec contents",
          "type": "string"
        },
        "reason": {
          "description": "High level class of failure",
          "type": "string"
        },
        "time": {
          "description": "Time failure occurred or was discovered",
          "$ref": "#/definitions/v1.Time"
        }
      }
    },
    "v1beta1.FineTunedWeight": {
      "description": "FineTunedWeight is the Schema for the finetunedweights API",
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.FineTunedWeightSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatusSpec"
        }
      }
    },
    "v1beta1.FineTunedWeightList": {
      "description": "FineTunedWeightList contains a list of FineTunedWeight",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.FineTunedWeight"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.FineTunedWeightSpec": {
      "description": "FineTunedWeightSpec defines the desired state of FineTunedWeight",
      "type": "object",
      "required": [
        "baseModelRef",
        "modelType",
        "hyperParameters",
        "storage"
      ],
      "properties": {
        "baseModelRef": {
          "description": "Reference to the base model that this weight is fine-tuned from",
          "default": {},
          "$ref": "#/definitions/v1beta1.ObjectReference"
        },
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "configuration": {
          "description": "Configuration of the fine-tuned weight, stored as generic JSON for flexibility",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "hyperParameters": {
          "description": "HyperParameters used for fine-tuning, stored as generic JSON for flexibility",
          "$ref": "#/definitions/k8s.io.apimachinery.pkg.runtime.RawExtension"
        },
        "modelType": {
          "description": "ModelType of the fine-tuned weight, e.g., \"Distillation\", \"Adapter\", \"Tfew\"",
          "type": "string"
        },
        "storage": {
          "description": "Storage configuration for the fine-tuned weight",
          "$ref": "#/definitions/v1beta1.StorageSpec"
        },
        "trainingJobRef": {
          "description": "TrainingJobID is the ID of the training job that produced this weight",
          "default": {},
          "$ref": "#/definitions/v1beta1.ObjectReference"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.HuggingFaceSecretReference": {
      "description": "HuggingFaceSecretReference defines a reference to a Kubernetes Secret containing the Hugging Face API key. This secret must reside in the same namespace as the BenchmarkJob. Cross-namespace references are not allowed for security and simplicity.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the secret containing the Hugging Face API key. The secret must reside in the same namespace as the BenchmarkJob.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.InferenceService": {
      "description": "InferenceService is the Schema for the InferenceServices API",
      "type": "object",
      "required": [
        "spec",
        "status"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.InferenceServiceSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.InferenceServiceStatus"
        }
      }
    },
    "v1beta1.InferenceServiceList": {
      "description": "InferenceServiceList contains a list of Service",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.InferenceService"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.InferenceServiceReference": {
      "description": "InferenceServiceReference defines the reference to a Kubernetes inference service.",
      "type": "object",
      "required": [
        "name",
        "namespace"
      ],
      "properties": {
        "name": {
          "description": "Name specifies the name of the inference service to benchmark.",
          "type": "string",
          "default": ""
        },
        "namespace": {
          "description": "Namespace specifies the Kubernetes namespace where the inference service is deployed. Cross-namespace references are allowed but require appropriate RBAC permissions.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.InferenceServiceSpec": {
      "description": "InferenceServiceSpec is the top level type for this resource",
      "type": "object",
      "properties": {
        "decoder": {
          "description": "Decoder defines the decoder spec This is specifically used for PD (Prefill-Decode) disaggregated serving deployments. Similar to Engine in structure, it allows for container and pod specifications, but is only utilized when implementing the disaggregated serving pattern to separate the prefill and decode phases of inference.",
          "$ref": "#/definitions/v1beta1.DecoderSpec"
        },
        "engine": {
          "description": "Engine defines the serving engine spec This provides detailed container and pod specifications for model serving. It allows defining the model runner (container spec), as well as complete pod specifications including init containers, sidecar containers, and other pod-level configurations. Engine can also be configured for multi-node deployments using leader and worker specifications.",
          "$ref": "#/definitions/v1beta1.EngineSpec"
        },
        "kedaConfig": {
          "description": "KedaConfig defines the autoscaling configuration for KEDA Provides settings for event-driven autoscaling using KEDA (Kubernetes Event-driven Autoscaling), allowing the service to scale based on custom metrics or event sources.",
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "model": {
          "description": "Model defines the model to be used for inference, referencing either a BaseModel or a custom model. This allows models to be managed independently of the serving configuration.",
          "$ref": "#/definitions/v1beta1.ModelRef"
        },
        "predictor": {
          "description": "Predictor defines the model serving spec It specifies how the model should be deployed and served, handling inference requests. Deprecated: Predictor is deprecated and will be removed in a future release. Please use Engine and Model fields instead.",
          "default": {},
          "$ref": "#/definitions/v1beta1.PredictorSpec"
        },
        "router": {
          "description": "Router defines the router spec",
          "$ref": "#/definitions/v1beta1.RouterSpec"
        },
        "runtime": {
          "description": "Runtime defines the serving runtime environment that will be used to execute the model. It is an inference service spec template that determines how the service should be deployed. Runtime is optional - if not defined, the operator will automatically select the best runtime based on the model's size, architecture, format, quantization, and framework.",
          "$ref": "#/definitions/v1beta1.ServingRuntimeRef"
        }
      }
    },
    "v1beta1.InferenceServiceStatus": {
      "description": "InferenceServiceStatus defines the observed state of InferenceService",
      "type": "object",
      "properties": {
        "address": {
          "description": "Addressable endpoint for the InferenceService",
          "$ref": "#/definitions/knative.Addressable"
        },
        "annotations": {
          "description": "Annotations is additional Status fields for the Resource to save some additional State as well as convey more information to the user. This is roughly akin to Annotations on any k8s resource, just the reconciler conveying richer information outwards.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "components": {
          "description": "Statuses for the components of the InferenceService",
          "type": "object",
          "additionalProperties": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ComponentStatusSpec"
          }
        },
        "conditions": {
          "description": "Conditions the latest available observations of a resource's current state.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/knative.Condition"
          },
          "x-kubernetes-patch-merge-key": "type",
          "x-kubernetes-patch-strategy": "merge"
        },
        "modelStatus": {
          "description": "Model related statuses",
          "default": {},
          "$ref": "#/definitions/v1beta1.ModelStatus"
        },
        "observedGeneration": {
          "description": "ObservedGeneration is the 'Generation' of the Service that was last processed by the controller.",
          "type": "integer",
          "format": "int64"
        },
        "url": {
          "description": "URL holds the url that will distribute traffic over the provided traffic targets. It generally has the form http[s]://{route-name}.{route-namespace}.{cluster-level-suffix}",
          "$ref": "#/definitions/knative.URL"
        }
      }
    },
    "v1beta1.KedaConfig": {
      "description": "KedaConfig stores the configuration settings for KEDA autoscaling within the InferenceService. It includes fields like the Prometheus server address, custom query, scaling threshold, and operator.",
      "type": "object",
      "properties": {
        "customPromQuery": {
          "description": "CustomPromQuery defines a custom Prometheus query that KEDA will execute to evaluate the desired metric for scaling. This query should return a single numerical value that represents the metric to be monitored.\n\nExample:\n  avg_over_time(http_requests_total{service=\"llama\"}[5m])",
          "type": "string"
        },
        "enableKeda": {
          "description": "EnableKeda determines whether KEDA autoscaling is enabled for the InferenceService. - true: KEDA will manage the autoscaling based on the provided configuration. - false: KEDA will not be used, and autoscaling will rely on other mechanisms (e.g., HPA).",
          "type": "boolean"
        },
        "promServerAddress": {
          "description": "PromServerAddress specifies the address of the Prometheus server that KEDA will query to retrieve metrics for autoscaling decisions. This should be a fully qualified URL, including the protocol and port number.\n\nExample:\n  http://prometheus-operated.monitoring.svc.cluster.local:9090",
          "type": "string"
        },
        "scalingOperator": {
          "description": "ScalingOperator specifies the comparison operator used by KEDA to decide whether to scale the Deployment. Common operators include: - \"GreaterThanOrEqual\": Scale up when the metric is \u003e= ScalingThreshold. - \"LessThanOrEqual\": Scale down when the metric is \u003c= ScalingThreshold.\n\nThis operator defines the condition under which scaling actions are triggered based on the evaluated metric.\n\nExample:\n  \"GreaterThanOrEqual\"",
          "type": "string"
        },
        "scalingThreshold": {
          "description": "ScalingThreshold sets the numerical threshold against which the result of the Prometheus query will be compared. Depending on the ScalingOperator, this threshold determines when to scale the number of replicas up or down.\n\nExample:\n  \"10\" - The Autoscaler will compare the metric value to 10.",
          "type": "string"
        }
      }
    },
    "v1beta1.LeaderSpec": {
      "description": "LeaderSpec defines the configuration for a leader node in a multi-node component The leader node coordinates the activities of worker nodes in distributed inference or token generation setups, handling task distribution and result aggregation.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the leader node's coordination logic.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.ModelCopies": {
      "type": "object",
      "required": [
        "failedCopies"
      ],
      "properties": {
        "failedCopies": {
          "description": "How many copies of this predictor's models failed to load recently",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "totalCopies": {
          "description": "Total number copies of this predictor's models that are currently loaded",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1beta1.ModelExtensionSpec": {
      "type": "object",
      "properties": {
        "compartmentID": {
          "description": "CompartmentID is the compartment ID of the model",
          "type": "string"
        },
        "disabled": {
          "description": "Whether the model is enabled or not",
          "type": "boolean"
        },
        "displayName": {
          "description": "DisplayName is the user-friendly name of the model",
          "type": "string"
        },
        "vendor": {
          "description": "Vendor of the model, e.g., \"NVIDIA\", \"Meta\", \"HuggingFace\"",
          "type": "string"
        },
        "version": {
          "type": "string"
        }
      }
    },
    "v1beta1.ModelFormat": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the format in which the model is stored, e.g., \"ONNX\", \"TensorFlow SavedModel\", \"PyTorch\", \"SafeTensors\"",
          "type": "string",
          "default": ""
        },
        "operator": {
          "description": "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFormat version",
          "type": "string"
        },
        "version": {
          "description": "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        },
        "weight": {
          "description": "Weight of the model format in the runtime selector, used to prioritize modelFormat",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ModelFrameworkSpec": {
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the library in which the model is stored, e.g., \"ONNXRuntime\", \"TensorFlow\", \"PyTorch\", \"Transformer\", \"TensorRTLLM\"",
          "type": "string",
          "default": ""
        },
        "operator": {
          "description": "Operator for the selector with supported values: \"Equal\", \"GreaterThan\" This is used to select the serving runtime based on the modelFramework version",
          "type": "string"
        },
        "version": {
          "description": "Version of the library. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        },
        "weight": {
          "description": "Weight of the framework in the runtime selector, used to prioritize modelFramework",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.ModelRef": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "description": "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced model.",
          "type": "string"
        },
        "fineTunedWeights": {
          "description": "Optional FineTunedWeights references References to fine-tuned weights that should be applied to the base model.",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "kind": {
          "description": "Kind of the model being referenced Defaults to ClusterBaseModel Specifies the Kubernetes resource kind of the referenced model.",
          "type": "string"
        },
        "name": {
          "description": "Name of the model being referenced Identifies the specific model to be used for inference.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ModelRevisionStates": {
      "type": "object",
      "required": [
        "activeModelState"
      ],
      "properties": {
        "activeModelState": {
          "description": "High level state string: Pending, Standby, Loading, Loaded, FailedToLoad",
          "type": "string",
          "default": ""
        },
        "targetModelState": {
          "type": "string"
        }
      }
    },
    "v1beta1.ModelSizeRangeSpec": {
      "description": "ModelSizeRangeSpec defines the range of model sizes supported by this runtime",
      "type": "object",
      "properties": {
        "max": {
          "description": "Maximum size of the model in bytes",
          "type": "string"
        },
        "min": {
          "description": "Minimum size of the model in bytes",
          "type": "string"
        }
      }
    },
    "v1beta1.ModelSpec": {
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "baseModel": {
          "type": "string"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "fineTunedWeights": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "protocolVersion": {
          "description": "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
          "type": "string"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "runtime": {
          "description": "Specific ClusterServingRuntime/ServingRuntime name to use for deployment.",
          "type": "string"
        },
        "runtimeVersion": {
          "description": "Runtime version of the predictor docker image",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "storageUri": {
          "description": "This field points to the location of the model which is mounted onto the pod.",
          "type": "string"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.ModelStatus": {
      "type": "object",
      "required": [
        "transitionStatus"
      ],
      "properties": {
        "lastFailureInfo": {
          "description": "Details of last failure, when load of target model is failed or blocked.",
          "$ref": "#/definitions/v1beta1.FailureInfo"
        },
        "modelCopies": {
          "description": "Model copy information of the predictor's model.",
          "$ref": "#/definitions/v1beta1.ModelCopies"
        },
        "modelRevisionStates": {
          "description": "State information of the predictor's model.",
          "$ref": "#/definitions/v1beta1.ModelRevisionStates"
        },
        "transitionStatus": {
          "description": "Whether the available predictor endpoints reflect the current Spec or is in transition",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ModelStatusSpec": {
      "description": "ModelStatusSpec defines the observed state of Model weight",
      "type": "object",
      "required": [
        "state"
      ],
      "properties": {
        "lifecycle": {
          "description": "LifeCycle is an enum of Deprecated, Experiment, Public, Internal",
          "type": "string"
        },
        "nodesFailed": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "nodesReady": {
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "state": {
          "description": "Status of the model weight",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ObjectReference": {
      "description": "ObjectReference contains enough information to let you inspect or modify the referred object.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the referenced object",
          "type": "string"
        },
        "namespace": {
          "description": "Namespace of the referenced object",
          "type": "string"
        }
      }
    },
    "v1beta1.PodOverride": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "env": {
          "description": "List of environment variables to set in the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Image specifies the container image to use for the benchmark job.",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-type": "atomic",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.PodSpec": {
      "description": "PodSpec is a description of a pod.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.PredictorExtensionSpec": {
      "description": "PredictorExtensionSpec defines configuration shared across all predictor frameworks",
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "protocolVersion": {
          "description": "Protocol version to use by the predictor (i.e. v1 or v2 or grpc-v1 or grpc-v2)",
          "type": "string"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "runtimeVersion": {
          "description": "Runtime version of the predictor docker image",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "storageUri": {
          "description": "This field points to the location of the model which is mounted onto the pod.",
          "type": "string"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.PredictorSpec": {
      "description": "PredictorSpec defines the configuration for a predictor, The following fields follow a \"1-of\" semantic. Users must specify exactly one spec.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "model": {
          "description": "Model spec for any arbitrary framework.",
          "$ref": "#/definitions/v1beta1.ModelSpec"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "workerSpec": {
          "description": "WorkerSpec for the predictor, this is used for multi-node serving without Ray Cluster",
          "$ref": "#/definitions/v1beta1.WorkerSpec"
        }
      }
    },
    "v1beta1.RouterSpec": {
      "description": "RouterSpec defines the configuration for the Router component, which handles request routing",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "canaryTrafficPercent": {
          "description": "CanaryTrafficPercent defines the traffic split percentage between the candidate revision and the last ready revision",
          "type": "integer",
          "format": "int64"
        },
        "config": {
          "description": "Additional configuration parameters for the runner This can include framework-specific settings",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containerConcurrency": {
          "description": "ContainerConcurrency specifies how many requests can be processed concurrently, this sets the hard limit of the container concurrency(https://knative.dev/docs/serving/autoscaling/concurrency).",
          "type": "integer",
          "format": "int64"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "deploymentStrategy": {
          "description": "The deployment strategy to use to replace existing pods with new ones. Only applicable for raw deployment mode.",
          "$ref": "#/definitions/k8s.io.api.apps.v1.DeploymentStrategy"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "kedaConfig": {
          "$ref": "#/definitions/v1beta1.KedaConfig"
        },
        "labels": {
          "description": "Labels that will be add to the component pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "maxReplicas": {
          "description": "Maximum number of replicas for autoscaling.",
          "type": "integer",
          "format": "int32"
        },
        "minReplicas": {
          "description": "Minimum number of replicas, defaults to 1 but can be set to 0 to enable scale-to-zero.",
          "type": "integer",
          "format": "int32"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "This is essentially a container spec that can override the default container",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "scaleMetric": {
          "description": "ScaleMetric defines the scaling metric type watched by autoscaler possible values are concurrency, rps, cpu, memory. concurrency, rps are supported via Knative Pod Autoscaler(https://knative.dev/docs/serving/autoscaling/autoscaling-metrics).",
          "type": "string"
        },
        "scaleTarget": {
          "description": "ScaleTarget specifies the integer target value of the metric type the Autoscaler watches for. concurrency and rps targets are supported by Knative Pod Autoscaler (https://knative.dev/docs/serving/autoscaling/autoscaling-targets/).",
          "type": "integer",
          "format": "int32"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "timeoutSeconds": {
          "description": "TimeoutSeconds specifies the number of seconds to wait before timing out a request to the component.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.RunnerSpec": {
      "description": "RunnerSpec defines container configuration plus additional config settings The Runner is the primary container that executes the model serving or token generation logic.",
      "type": "object",
      "properties": {
        "args": {
          "description": "Arguments to the entrypoint. The container image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "command": {
          "description": "Entrypoint array. Not executed within a shell. The container image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. \"$$(VAR_NAME)\" will produce the string literal \"$(VAR_NAME)\". Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "env": {
          "description": "List of environment variables to set in the container. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvVar"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "envFrom": {
          "description": "List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EnvFromSource"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "image": {
          "description": "Container image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.",
          "type": "string"
        },
        "imagePullPolicy": {
          "description": "Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images",
          "type": "string"
        },
        "lifecycle": {
          "description": "Actions that the management system should take in response to container lifecycle events. Cannot be updated.",
          "$ref": "#/definitions/v1.Lifecycle"
        },
        "livenessProbe": {
          "description": "Periodic probe of container liveness. Container will be restarted if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "name": {
          "description": "Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.",
          "type": "string",
          "default": ""
        },
        "ports": {
          "description": "List of ports to expose from the container. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default \"0.0.0.0\" address inside a container will be accessible from the network. Modifying this array with strategic merge patch may corrupt the data. For more information See https://github.com/kubernetes/kubernetes/issues/108255. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerPort"
          },
          "x-kubernetes-list-map-keys": [
            "containerPort",
            "protocol"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "containerPort",
          "x-kubernetes-patch-strategy": "merge"
        },
        "readinessProbe": {
          "description": "Periodic probe of container service readiness. Container will be removed from service endpoints if the probe fails. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "resizePolicy": {
          "description": "Resources resize policy for the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.ContainerResizePolicy"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resources": {
          "description": "Compute Resources required by this container. Cannot be updated. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/",
          "default": {},
          "$ref": "#/definitions/v1.ResourceRequirements"
        },
        "restartPolicy": {
          "description": "RestartPolicy defines the restart behavior of individual containers in a pod. This field may only be set for init containers, and the only allowed value is \"Always\". For non-init containers or when this field is not specified, the restart behavior is defined by the Pod's restart policy and the container type. Setting the RestartPolicy as \"Always\" for the init container will have the following effect: this init container will be continually restarted on exit until all regular containers have terminated. Once all regular containers have completed, all init containers with restartPolicy \"Always\" will be shut down. This lifecycle differs from normal init containers and is often referred to as a \"sidecar\" container. Although this init container still starts in the init container sequence, it does not wait for the container to complete before proceeding to the next init container. Instead, the next init container starts immediately after this init container is started, or after any startupProbe has successfully completed.",
          "type": "string"
        },
        "securityContext": {
          "description": "SecurityContext defines the security options the container should be run with. If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext. More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "$ref": "#/definitions/v1.SecurityContext"
        },
        "startupProbe": {
          "description": "StartupProbe indicates that the Pod has successfully initialized. If specified, no other probes are executed until this completes successfully. If this probe fails, the Pod will be restarted, just as if the livenessProbe failed. This can be used to provide different probe parameters at the beginning of a Pod's lifecycle, when it might take a long time to load data or warm a cache, than during steady-state operation. This cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes",
          "$ref": "#/definitions/v1.Probe"
        },
        "stdin": {
          "description": "Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.",
          "type": "boolean"
        },
        "stdinOnce": {
          "description": "Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false",
          "type": "boolean"
        },
        "terminationMessagePath": {
          "description": "Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.",
          "type": "string"
        },
        "terminationMessagePolicy": {
          "description": "Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.",
          "type": "string"
        },
        "tty": {
          "description": "Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.",
          "type": "boolean"
        },
        "volumeDevices": {
          "description": "volumeDevices is the list of block devices to be used by the container.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeDevice"
          },
          "x-kubernetes-list-map-keys": [
            "devicePath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "devicePath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumeMounts": {
          "description": "Pod volumes to mount into the container's filesystem. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.VolumeMount"
          },
          "x-kubernetes-list-map-keys": [
            "mountPath"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "mountPath",
          "x-kubernetes-patch-strategy": "merge"
        },
        "workingDir": {
          "description": "Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.",
          "type": "string"
        }
      }
    },
    "v1beta1.ServiceMetadata": {
      "description": "ServiceMetadata contains metadata fields for recording the backend model server's configuration and version details. This information helps track experiment context, enabling users to filter and query experiments based on server properties.",
      "type": "object",
      "required": [
        "engine",
        "version",
        "gpuType",
        "gpuCount"
      ],
      "properties": {
        "engine": {
          "description": "Engine specifies the backend model server engine. Supported values: \"vLLM\", \"SGLang\", \"TGI\".",
          "type": "string",
          "default": ""
        },
        "gpuCount": {
          "description": "GpuCount indicates the number of GPU cards available on the model server.",
          "type": "integer",
          "format": "int32",
          "default": 0
        },
        "gpuType": {
          "description": "GpuType specifies the type of GPU used by the model server. Supported values: \"H100\", \"A100\", \"MI300\", \"A10\".",
          "type": "string",
          "default": ""
        },
        "version": {
          "description": "Version specifies the version of the model server (e.g., \"0.5.3\").",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ServingRuntime": {
      "description": "ServingRuntime is the Schema for the servingruntimes API",
      "type": "object",
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ObjectMeta"
        },
        "spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        },
        "status": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeStatus"
        }
      }
    },
    "v1beta1.ServingRuntimeList": {
      "description": "ServingRuntimeList contains a list of ServingRuntime",
      "type": "object",
      "required": [
        "items"
      ],
      "properties": {
        "apiVersion": {
          "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
          "type": "string"
        },
        "items": {
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.ServingRuntime"
          }
        },
        "kind": {
          "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
          "type": "string"
        },
        "metadata": {
          "default": {},
          "$ref": "#/definitions/v1.ListMeta"
        }
      }
    },
    "v1beta1.ServingRuntimePodSpec": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.ServingRuntimeRef": {
      "type": "object",
      "properties": {
        "apiGroup": {
          "description": "APIGroup of the resource being referenced Defaults to `ome.io` Specifies the Kubernetes API group of the referenced runtime.",
          "type": "string"
        },
        "kind": {
          "description": "Kind of the runtime being referenced Defaults to ClusterServingRuntime Specifies the Kubernetes resource kind of the referenced runtime. ClusterServingRuntime is a cluster-wide runtime, while ServingRuntime is namespace-scoped.",
          "type": "string"
        },
        "name": {
          "description": "Name of the runtime being referenced Identifies the specific runtime environment to be used for model execution.",
          "type": "string",
          "default": ""
        }
      }
    },
    "v1beta1.ServingRuntimeSpec": {
      "description": "ServingRuntimeSpec defines the desired state of ServingRuntime. This spec is currently provisional and are subject to change as details regarding single-model serving and multi-model serving are hammered out.",
      "type": "object",
      "properties": {
        "acceleratorRequirements": {
          "description": "AcceleratorRequirements specifies the accelerator requirements for this runtime",
          "$ref": "#/definitions/v1beta1.AcceleratorRequirements"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "decoderConfig": {
          "description": "Decoder configuration for this runtime",
          "$ref": "#/definitions/v1beta1.DecoderSpec"
        },
        "disabled": {
          "description": "Set to true to disable use of this runtime",
          "type": "boolean"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "engineConfig": {
          "description": "Engine configuration for this runtime",
          "$ref": "#/definitions/v1beta1.EngineSpec"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "modelSizeRange": {
          "description": "ModelSizeRange is the range of model sizes supported by this runtime",
          "$ref": "#/definitions/v1beta1.ModelSizeRangeSpec"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "protocolVersions": {
          "description": "Supported protocol versions (i.e. openAI or cohere or openInference-v1 or openInference-v2)",
          "type": "array",
          "items": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-list-type": "atomic"
        },
        "routerConfig": {
          "description": "Router configuration for this runtime",
          "$ref": "#/definitions/v1beta1.RouterSpec"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "supportedModelFormats": {
          "description": "Model formats and version supported by this runtime",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1beta1.SupportedModelFormat"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "workers": {
          "description": "WorkerPodSpec for the serving runtime, this is used for multi-node serving without Ray Cluster",
          "$ref": "#/definitions/v1beta1.WorkerPodSpec"
        }
      }
    },
    "v1beta1.ServingRuntimeStatus": {
      "description": "ServingRuntimeStatus defines the observed state of ServingRuntime",
      "type": "object"
    },
    "v1beta1.StorageSpec": {
      "type": "object",
      "required": [
        "storageUri"
      ],
      "properties": {
        "key": {
          "description": "StorageKey is the name of the key in a Kubernetes Secret used to authenticate access to the model storage. This key will be used to fetch credentials during model download or access.",
          "type": "string"
        },
        "nodeAffinity": {
          "description": "NodeAffinity describes the node affinity rules that further constrain which nodes are eligible to download and store this model, based on advanced scheduling policies.",
          "$ref": "#/definitions/v1.NodeAffinity"
        },
        "nodeSelector": {
          "description": "NodeSelector defines a set of key-value label pairs that must be present on a node for the model to be scheduled and downloaded onto that node.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "parameters": {
          "description": "Parameters contain key-value pairs to override default storage credentials or configuration. These values are typically used to configure access to object storage or mount options.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "path": {
          "description": "Path is the absolute path where the model will be downloaded and stored on the node.",
          "type": "string"
        },
        "schemaPath": {
          "description": "SchemaPath is the path to the model schema or configuration file within the storage system. This can be used to validate the model or customize how it's loaded.",
          "type": "string"
        },
        "storageUri": {
          "description": "StorageUri specifies the source URI of the model in a supported storage backend. Supported formats: - OCI Object Storage:   oci://n/{namespace}/b/{bucket}/o/{object_path} - Persistent Volume:    pvc://{pvc-name}/{sub-path} - Vendor-specific:      vendor://{vendor-name}/{resource-type}/{resource-path} This field is required.",
          "type": "string"
        }
      }
    },
    "v1beta1.SupportedModelFormat": {
      "type": "object",
      "required": [
        "modelFormat",
        "modelFramework"
      ],
      "properties": {
        "acceleratorConfig": {
          "description": "AcceleratorConfig provides accelerator-specific overrides for this model format",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1beta1.AcceleratorModelConfig"
          }
        },
        "autoSelect": {
          "description": "Set to true to allow the ServingRuntime to be used for automatic model placement if this model format is specified with no explicit runtime.",
          "type": "boolean"
        },
        "modelArchitecture": {
          "description": "ModelArchitecture of the model, e.g., \"LlamaForCausalLM\", \"GemmaForCausalLM\", \"MixtralForCausalLM\"",
          "type": "string"
        },
        "modelFormat": {
          "description": "ModelFormat of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"SafeTensors\"",
          "$ref": "#/definitions/v1beta1.ModelFormat"
        },
        "modelFramework": {
          "description": "ModelFramework of the model, e.g., \"PyTorch\", \"TensorFlow\", \"ONNX\", \"Transformers\"",
          "$ref": "#/definitions/v1beta1.ModelFrameworkSpec"
        },
        "modelType": {
          "description": "DEPRECATED: This field is deprecated and will be removed in future releases.",
          "type": "string"
        },
        "name": {
          "description": "Name of the model",
          "type": "string",
          "default": ""
        },
        "priority": {
          "description": "Priority of this serving runtime for auto selection. This is used to select the serving runtime if more than one serving runtime supports the same model format. The value should be greater than zero.  The higher the value, the higher the priority. Priority is not considered if AutoSelect is either false or not specified. Priority can be overridden by specifying the runtime in the InferenceService.",
          "type": "integer",
          "format": "int32"
        },
        "quantization": {
          "description": "Quantization of the model, e.g., \"fp8\", \"fbgemm_fp8\", \"int4\"",
          "type": "string"
        },
        "version": {
          "description": "Version of the model format. Used in validating that a runtime supports a predictor. It Can be \"major\", \"major.minor\" or \"major.minor.patch\".",
          "type": "string"
        }
      }
    },
    "v1beta1.SupportedRuntime": {
      "description": "SupportedRuntime is the schema for supported runtime result of automatic selection",
      "type": "object",
      "required": [
        "Name",
        "Spec"
      ],
      "properties": {
        "Name": {
          "type": "string",
          "default": ""
        },
        "Spec": {
          "default": {},
          "$ref": "#/definitions/v1beta1.ServingRuntimeSpec"
        }
      }
    },
    "v1beta1.TensorParallelismConfig": {
      "description": "TensorParallelismConfig specifies tensor parallelism settings",
      "type": "object",
      "properties": {
        "dataParallelSize": {
          "description": "dataParallelSize specifies the size of the data parallelism",
          "type": "integer",
          "format": "int64"
        },
        "pipelineParallelSize": {
          "description": "pipelineParallelSize specifies the size of the pipeline parallelism",
          "type": "integer",
          "format": "int64"
        },
        "tensorParallelSize": {
          "description": "tensorParallelSize specifies the size of the tensor parallelism",
          "type": "integer",
          "format": "int64"
        }
      }
    },
    "v1beta1.WorkerPodSpec": {
      "type": "object",
      "properties": {
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "annotations": {
          "description": "Annotations that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "labels": {
          "description": "Labels that will be add to the pod. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          }
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "size": {
          "description": "Size of the worker, this is the number of pods in the worker.",
          "type": "integer",
          "format": "int32"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    },
    "v1beta1.WorkerSpec": {
      "description": "WorkerSpec defines the configuration for worker nodes in a multi-node component Worker nodes perform the distributed processing tasks assigned by the leader node, enabling horizontal scaling for compute-intensive workloads.",
      "type": "object",
      "properties": {
        "activeDeadlineSeconds": {
          "description": "Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.",
          "type": "integer",
          "format": "int64"
        },
        "affinity": {
          "description": "If specified, the pod's scheduling constraints",
          "$ref": "#/definitions/v1.Affinity"
        },
        "automountServiceAccountToken": {
          "description": "AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.",
          "type": "boolean"
        },
        "containers": {
          "description": "List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "dnsConfig": {
          "description": "Specifies the DNS parameters of a pod. Parameters specified here will be merged to the generated DNS configuration based on DNSPolicy.",
          "$ref": "#/definitions/v1.PodDNSConfig"
        },
        "dnsPolicy": {
          "description": "Set DNS policy for the pod. Defaults to \"ClusterFirst\". Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'. DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy. To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.",
          "type": "string"
        },
        "enableServiceLinks": {
          "description": "EnableServiceLinks indicates whether information about services should be injected into pod's environment variables, matching the syntax of Docker links. Optional: Defaults to true.",
          "type": "boolean"
        },
        "ephemeralContainers": {
          "description": "List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing pod to perform user-initiated actions such as debugging. This list cannot be specified when creating a pod, and it cannot be modified by updating the pod spec. In order to add an ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.EphemeralContainer"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostAliases": {
          "description": "HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.HostAlias"
          },
          "x-kubernetes-list-map-keys": [
            "ip"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "ip",
          "x-kubernetes-patch-strategy": "merge"
        },
        "hostIPC": {
          "description": "Use the host's ipc namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostNetwork": {
          "description": "Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.",
          "type": "boolean"
        },
        "hostPID": {
          "description": "Use the host's pid namespace. Optional: Default to false.",
          "type": "boolean"
        },
        "hostUsers": {
          "description": "Use the host's user namespace. Optional: Default to true. If set to true or not present, the pod will be run in the host user namespace, useful for when the pod needs a feature only available to the host user namespace, such as loading a kernel module with CAP_SYS_MODULE. When set to false, a new userns is created for the pod. Setting false is useful for mitigating container breakout vulnerabilities even allowing users to run their containers as root without actually having root privileges on the host. This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.",
          "type": "boolean"
        },
        "hostname": {
          "description": "Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.",
          "type": "string"
        },
        "imagePullSecrets": {
          "description": "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.LocalObjectReference"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "initContainers": {
          "description": "List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Container"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "nodeName": {
          "description": "NodeName indicates in which node this pod is scheduled. If empty, this pod is a candidate for scheduling by the scheduler defined in schedulerName. Once this field is set, the kubelet for this node becomes responsible for the lifecycle of this pod. This field should not be used to express a desire for the pod to be scheduled on a specific node. https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodename",
          "type": "string"
        },
        "nodeSelector": {
          "description": "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "default": ""
          },
          "x-kubernetes-map-type": "atomic"
        },
        "os": {
          "description": "Specifies the OS of the containers in the pod. Some pod and container fields are restricted if this is set.\n\nIf the OS field is set to linux, the following fields must be unset: -securityContext.windowsOptions\n\nIf the OS field is set to windows, following fields must be unset: - spec.hostPID - spec.hostIPC - spec.hostUsers - spec.securityContext.appArmorProfile - spec.securityContext.seLinuxOptions - spec.securityContext.seccompProfile - spec.securityContext.fsGroup - spec.securityContext.fsGroupChangePolicy - spec.securityContext.sysctls - spec.shareProcessNamespace - spec.securityContext.runAsUser - spec.securityContext.runAsGroup - spec.securityContext.supplementalGroups - spec.securityContext.supplementalGroupsPolicy - spec.containers[*].securityContext.appArmorProfile - spec.containers[*].securityContext.seLinuxOptions - spec.containers[*].securityContext.seccompProfile - spec.containers[*].securityContext.capabilities - spec.containers[*].securityContext.readOnlyRootFilesystem - spec.containers[*].securityContext.privileged - spec.containers[*].securityContext.allowPrivilegeEscalation - spec.containers[*].securityContext.procMount - spec.containers[*].securityContext.runAsUser - spec.containers[*].securityContext.runAsGroup",
          "$ref": "#/definitions/v1.PodOS"
        },
        "overhead": {
          "description": "Overhead represents the resource overhead associated with running a pod for a given RuntimeClass. This field will be autopopulated at admission time by the RuntimeClass admission controller. If the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests. The RuntimeClass admission controller will reject Pod create requests which have the overhead already set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero. More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md",
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/resource.Quantity"
          }
        },
        "preemptionPolicy": {
          "description": "PreemptionPolicy is the Policy for preempting pods with lower priority. One of Never, PreemptLowerPriority. Defaults to PreemptLowerPriority if unset.",
          "type": "string"
        },
        "priority": {
          "description": "The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.",
          "type": "integer",
          "format": "int32"
        },
        "priorityClassName": {
          "description": "If specified, indicates the pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.",
          "type": "string"
        },
        "readinessGates": {
          "description": "If specified, all readiness gates will be evaluated for pod readiness. A pod is ready when all its containers are ready AND all conditions specified in the readiness gates have status equal to \"True\" More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodReadinessGate"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "resourceClaims": {
          "description": "ResourceClaims defines which ResourceClaims must be allocated and reserved before the Pod is allowed to start. The resources will be made available to those containers which consume them by name.\n\nThis is an alpha field and requires enabling the DynamicResourceAllocation feature gate.\n\nThis field is immutable.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodResourceClaim"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        },
        "restartPolicy": {
          "description": "Restart policy for all containers within the pod. One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy",
          "type": "string"
        },
        "runner": {
          "description": "Runner container override for customizing the main container This is essentially a container spec that can override the default container Provides fine-grained control over the container that executes the worker node's processing logic.",
          "$ref": "#/definitions/v1beta1.RunnerSpec"
        },
        "runtimeClassName": {
          "description": "RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run. If unset or empty, the \"legacy\" RuntimeClass will be used, which is an implicit class with an empty definition that uses the default runtime handler. More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class",
          "type": "string"
        },
        "schedulerName": {
          "description": "If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.",
          "type": "string"
        },
        "schedulingGates": {
          "description": "SchedulingGates is an opaque list of values that if specified will block scheduling the pod. If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the scheduler will not attempt to schedule the pod.\n\nSchedulingGates can only be set at pod creation time, and be removed only afterwards.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.PodSchedulingGate"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge"
        },
        "securityContext": {
          "description": "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
          "$ref": "#/definitions/v1.PodSecurityContext"
        },
        "serviceAccount": {
          "description": "DeprecatedServiceAccount is a deprecated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.",
          "type": "string"
        },
        "serviceAccountName": {
          "description": "ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
          "type": "string"
        },
        "setHostnameAsFQDN": {
          "description": "If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default). In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname). In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Services\\\\Tcpip\\\\Parameters to FQDN. If a pod does not have FQDN, this has no effect. Default to false.",
          "type": "boolean"
        },
        "shareProcessNamespace": {
          "description": "Share a single process namespace between all of the containers in a pod. When this is set containers will be able to view and signal processes from other containers in the same pod, and the first process in each container will not be assigned PID 1. HostPID and ShareProcessNamespace cannot both be set. Optional: Default to false.",
          "type": "boolean"
        },
        "size": {
          "description": "Size of the worker, this is the number of pods in the worker. Controls how many worker pod instances will be deployed for horizontal scaling.",
          "type": "integer",
          "format": "int32"
        },
        "subdomain": {
          "description": "If specified, the fully qualified Pod hostname will be \"\u003chostname\u003e.\u003csubdomain\u003e.\u003cpod namespace\u003e.svc.\u003ccluster domain\u003e\". If not specified, the pod will not have a domainname at all.",
          "type": "string"
        },
        "terminationGracePeriodSeconds": {
          "description": "Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates stop immediately via the kill signal (no opportunity to shut down). If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.",
          "type": "integer",
          "format": "int64"
        },
        "tolerations": {
          "description": "If specified, the pod's tolerations.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Toleration"
          },
          "x-kubernetes-list-type": "atomic"
        },
        "topologySpreadConstraints": {
          "description": "TopologySpreadConstraints describes how a group of pods ought to spread across topology domains. Scheduler will schedule pods in a way which abides by the constraints. All topologySpreadConstraints are ANDed.",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.TopologySpreadConstraint"
          },
          "x-kubernetes-list-map-keys": [
            "topologyKey",
            "whenUnsatisfiable"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "topologyKey",
          "x-kubernetes-patch-strategy": "merge"
        },
        "volumes": {
          "description": "List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes",
          "type": "array",
          "items": {
            "default": {},
            "$ref": "#/definitions/v1.Volume"
          },
          "x-kubernetes-list-map-keys": [
            "name"
          ],
          "x-kubernetes-list-type": "map",
          "x-kubernetes-patch-merge-key": "name",
          "x-kubernetes-patch-strategy": "merge,retainKeys"
        }
      }
    }
  }
}
